---
categories: 软件设计师
layout:     post
title:      "软件设计师考试重点"
date:       2021-02-06 12:30:11
author:     "Balbo"
header-img: "img/post-bg-2019.jpg"
catalog: true
tags:
    - 软件设计师
---

**第一章：计算机组成原理与体系结**

  考点1：运算器和控制器

1. 运算器
   1. 算术逻辑单元ALU：数据的算术运算和逻辑运算
   2. 累加寄存器AC：通用寄存器，为ALU提供一个工作区，用在暂存数据
   3. 数据缓冲寄存器DR：写内存时，暂存指令或数据
   4.  状态条件寄存器PSW：存储状态标志与控制标志

 


2. 控制器
   1. 程序计数器PC：存储下一条要执行指令的地址
   2. 指令寄存器IR：存储即将执行的指令
   3. 指令译码器ID：对指令中的操作码字段进行分析解释
   4.  时序部件：提供时序控制信号

 

  考点2：数据的表示

1. 进制转换
   1.  R进制转十进制：按权展开
   2. 十进制转R进制：短除法
   3.  二进制转八、十六进制：分组快速转换

 

2. 数据编码
   1. 原码：正数的原码是它本身，负数的原码是符号位为1
   2. 反码：正数的反码是它本身，负数的反码是除符号位不变，其他位取反
   3.  补码：正数的补码是它本身，负数的补码是负数的反码+1
   4. 移码：将补码的最高位取反

​         [![编码的表示范围](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190811131445409-888662501.png)](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190811131445409-888662501.png)

 

3. 浮点数
   1. 浮点数的表示：N=M*Re，M为尾数，R为基数，e为阶码
      1. 尾数用补码表示，阶码用移码表示
      2. 尾数的位数决定数的有效精度，位数越多精度越高
      3. 阶码的位数决定数的表示范围，位数越多范围越大
   2. 浮点数的运算
      1.  对阶，将阶码小的扩大，使两个数的阶码相同
      2. 求尾数和(差)
      3. 结果规格化并判断溢出

 

  考点3：Flynn分类法

​        [![Flynn分类法](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190811141948375-1061116138.png)](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190811141948375-1061116138.png)

 

  考点4：CISC与RISC

​        [![CISC和RISC](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190811143050753-285273506.png)](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190811143050753-285273506.png)

  

  考点5：流水线技术

1. 流水线相关概念
   1. 流水线：流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术
   2. 流水线建立时间：1条指令执行时间
   3. 流水线周期：执行时间最长的一段
   4. 吞吐率：单位时间内流水线处理机流出的结果。对指令而言就是单位时间内执行的指令数。

 

2. 流水线相关计算
   1.  流水线执行时间
      1. 理论公式：(t1+t2+..+tk)+(n-1)*∆t*
      2. *实践公式：k*∆t +(n-1)*∆t
   2. 吞吐率
      1. 吞吐率：TP = 指令条数 / 流水线执行时间
      2. 最大吞吐率：1 / ∆t
   3. 流水线加速比：顺序执行时间 / 流水线执行时间

 

  考点6：存储系统

1. 分级存储系统

   1. 存储体系结构

      ​    [![存储体系结构](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190812113405901-1475198210.png)](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190812113405901-1475198210.png)

   2. 局部性原理

      1. 概念：程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域
      2. 时间局部性：如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行
      3. 空间局部性：一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问

 

2. Cache(高速缓存)
   1. 作用：提高CPU对主存的访问速度。Cache是访问速度最快的层次。
   2. 特点：容量小，速度快，成本高
   3. 性能分析：若H代表对Cache的命中率，tc为Cache的读写时间，tm为主存的读写时间，则Cache的等效访问时间ta为：*ta = Htc + (1-H)tm*
   4. Cache映像方式 

​           [![Cache映像方式](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190812140726988-2071896819.png)](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190812140726988-2071896819.png)

 

​     \3. 主存

​        \1. 内存单元数：最大地址+1-最小地址

​        \2. 内存总容量：按字节编址，内存单元数*8bit；按字编址，内存单元数*机器字长

​        \3. 已知芯片单位容量，求所用芯片的片数，总容量/单位容量

​        \4. 已知所用芯片的片数，求取芯片单位容量，总容量/芯片片数

 

  考点7：总线系统

​      \1. 数据总线（Data Bus）：在CPU与RAM之间来回传送需要处理或是需要储存的数据。

​     \2. 地址总线（Address Bus）：用来指定在RAM之中储存的数据的地址。

​     \3. 控制总线（Control Bus）：将微处理器控制单元的信号，传送到周边设备，一般常见的为 USB Bus和1394 Bus。

 

  考点8：可靠性

​     \1. 串联系统计算：R总=R1*R2;

​     \2. 并联系统计算：R总=1-（1-R）2；

​     \3. N模混联系统：先将整个系统划分为多个部分串联R1、R2…等，再计算R1、R2内部的并联可靠性，带入原公式

 

  考点9：校验码

1. 奇偶校验
   1.  基本思想：在编码中增加一位校验位使编码中1的个数为奇数(奇校验)或者为偶数(偶校验)
   2. 特点：只能检测出奇数位出错但不知道哪位出错，并且不可以纠正
2. 循环冗余校验码
   1. 基本思想：利用生成多项式为 k 个数据位产生 r 个校验位来进行编码，其编码长度为 k+r，运用模二除法计算校验码
   2. 特点：可以检错但不能纠错
3. 海明码
   1. 基本思想：在n个数据位之间加上k个校验位(n和k必须满足 2k - 1 ≥ n+k 的关系)，通过扩大码距来实现检错和纠错。      
   2.  特点：可以检错和纠错

 

**第二章：操作系统**

  考点1：进程管理

​     \1. 进程的状态

​        \1. 三态模型

​             [![三态模型](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190813101744532-43139088.png)](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190813101744532-43139088.png)

​        \2. 五态模型

​             [![五态模型](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190813102212816-1553462484.png)](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190813102212816-1553462484.png)           

 

​     \2. 前趋图

​        \1. 组成：前趋图是一个有向无循环图，由节点和有向线段组成，节点表示进程或程序段，有向线段表示节点间的前趋关系

​        \2. 表示：两程序段 Pi 和 Pj 的前趋关系表示为 Pi → Pj ，其中 Pi 是Pj 的前趋， Pj 是 Pi 的后继， 含义是 Pi 执行完毕才能由 Pj 执行        

 

​     \3. 信号量与PV操作

​        \1. 同步、互斥、临界资源、临界区

​           \1. 临界资源：各进程采取互斥的方式，实现共享的资源称作临界资源

​           \2. 临界区：每个进程中访问临界资源的那段代码称为临界区，临界区中的临界资源同一时间只能由一个进程(线程)访问

​           \3. 互斥：互斥是进程(线程)之间的间接制约关系。当一个进程(线程)进入临界区使用临界资源时，另一个进程(线程)必须等待。只有当

​                  使用临界资源的进程退出临界区后，这个进程(线程)才会解除阻塞状态

​           \4. 同步：同步是进程(线程)之间的直接的制约关系。相互合作的进程(线程)需要在某些确定点上协调他们的工作，当一个进程(线程)

​                  达到这些点后，除非另一个进程(线程)已经完成某些操作，否则只能等待这些操作结束

 

​        \2. 信号量：信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程，值与相应资源的使用情况有关。

​           \1. 值 *S ≥ 0*：表示某资源的可用数

​           \2. 值 *S < 0*：其绝对值表示阻塞队列中等待该资源的进程数

 

​        \3. P 操作定义：S := S - 1 ，将信号量 S 的值减一

​           \1. 若 *S ≥ 0*，则执行 P 操作的进程继续执行

​           \2. 若 *S < 0*，则置该进程为阻塞状态，并将其插入阻塞队列中

 

​        \4. V 操作定义：S := S + 1，将信号量 S 的值加一

​           \1. 若 *S > 0*，则执行 V 操作的进程继续执行

​           \2. 若 *S ≤ 0*，则从阻塞状态唤醒一个进程，并将其插入就绪队列，执行 V 操作的进程继续执行

​           [![img](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190813112419277-1183273183.png)](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190813112419277-1183273183.png)

 

​     \4. 死锁及银行家算法

​         \1. 死锁

​            \1. 概念：两个以上的进程(线程)互相都因要求对方已经占有的资源导致无法运行下去的现象，产生的原因是资源竞争及进程推进顺序非法

​            \2. 产生条件：

​               \1. 互斥条件：进程对其要求的资源进行排他性控制，即一次只允许一个进程使用

​               \2. 请求保持条件：零星的请求资源，即获得部分资源后又请求其他资源被堵塞并对已获得的资源保持不放

​               \3. 不剥夺条件：进程已获得资源在未使用完之前不能被剥夺，只能在使用完后自己释放

​               \4. 环路条件：在进程资源有向图中必构成环路，其中每个进程占有下一个进程申请的一个或多个资源

 

​              \3. 处理

​                 \1. 预防：使用预先静态分配法和资源有序分配法来预防

​               \2. 避免：银行家算法

​               \3. 检测：允许死锁发生，但程序会定时运行一个“死锁检测”程序，如果检测到死锁，则设法加以解除。

​               \4. 解除：使用资源剥夺法和撤销进程法解除死锁

 

​          \2. 银行家算法

​            \1. 相关概念

​               \1. Available：可利用资源向量，它是一个含有 m个元素的数组，其中每个元素代表一类可利用资源的数目
​               \2. Max：最大需求矩阵，n*m矩阵，表示n个进程的每一个对m类资源的最大需求
​               \3. Allocation：分配矩阵，n*m矩阵，表示每个进程已分配的每类资源的数目
​               \4. Need：需求矩阵，n*m矩阵，表示每个进程还需要各类资源数

​               Need[i,j]= Max[i,j]- Allocation[i,j]

 

​             \2. 算法步骤

​               \1. 请求性算法步骤

​                  设*Request i* 为进程 Pi 的请求向量。如果 *Request i[ j ] == k* 那么进程 Pi 需要资源 Rj 的实例数量为 k，

​                  当进程 Pi 作出资源请求时，执行下列步骤：

​                  \1. 若Request i[ j ] ≤ Need[ i, j ]，转步骤（2）；否则错误返回，因为进程 Pi 超过其最大请求

​                  \2. 若Request i[ j ] ≤ Available[ j ]，转步骤（3）；否则进程 Pi 等待，因为没有可用资源

​                  \3. 假设系统分配了进程 Pi 所请求的资源，则有：

​                     Available [ j] := Available [ j] - Request i[ j]；

​                     Allocation[i, j] := Allocation[i, j]+Request i[ j]；

​                     Need[i, j] := Need[i, j] - Request i[ j]

 

​               \2. 安全性算法步骤

​                  若系统新状态是安全的，则完成分配；若系统新状态是不安全的，则恢复原状态，进程等待

​                  \1. Work[ j] := Available[ j]；Finish[ i] := false;

​                  \2. 寻找满足条件的 i ：Finish[ i] = false；Need[i, j] ≤ Work[ j]；若不存在，转步骤（4）；

​                  \3. Work[ j] := Work[ j] + Allocation[i, j]；Finish[ i] := true；转步骤（2）

​                  \4. 若对所有 i，Finish[ i] = true，则系统处于安全状态，否则处于不安全状态

 

  考点2：存储管理

​     \1. 页式存储

​        \1. 基本原理

​           \1. 页或页面：系统将进程的地址空间划分成若干大小相等的区域，称为页或页面

​           \2. 块或页框：系统将主存空间划分成与页相同大小的若干物理块，称为块或页框

​           \3. 内存分配：在为进程分配主存时，将进程中若干页分别装入多个不相邻的块中

 

​         \2. 地址结构

​           \1. 组成：页号P和偏移量W(页内地址)。0~11位为页内地址(4KB)，12~31位为页号(1MB)

​             [![img](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190813200847608-2114147230.png)](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190813200847608-2114147230.png)

 

​            \2. 地址变换

​                 [![img](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190824111806858-866427204.jpg)](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190824111806858-866427204.jpg)

​            \1. 页号P = 逻辑地址 / 页面大小；页内地址 = 逻辑地址 % 页面大小

​           \2. 物理地址 = 物理块号(页号对应) * 页面大小 + 页内偏移

 

​        \3. 页表

​           \1. 概念：系统为了保证能够在主存中找到每个页面所对应的物理块，为每个进程建立了一张页面映射表，简称页表。

​                  每个页面在页表中占一个表项，记录该页面在主存中对应的物理块号。进程在执行时，通过查找页表可以找到每页所对应的物理块号

​           \2. 作用：实现从页号到物理号的地址映射

​          

​        \4. 快表

​           \1. 概念：在地址映射过程中，共需两次访问主存。第一次访问页表，得到数据的物理地址，第二次才是存取数据。

​                  在地址映射机制中增加一个小容量的联想寄存器(相联存储器)，称为快表

​           \2. 作用：存放当前访问最频繁的少数页的页号及相关信息

 

​     \2. 段式存储

​        \1. 基本原理

​           段是按照程序的自然分界划分的长度可以动态改变的区域，每段是一组完整的逻辑信息，地址连续，长度不同

 

​        \2. 地址变换

​            [![img](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190824113341000-20059534.jpg)](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190824113341000-20059534.jpg)

​           \1. 存储管理部件首先以段号S为索引访问段表的第S个表项

​              \1. 若该表项的有效位为1，则将虚拟地址的段内地址D与该表项的段长字段比较；

​                 \1. 若段内地址较大则说明地址越界，将产生地址越界中断；

​                 \2. 否则，将该表项的段起址与段内地址相加，求得主存实际地址并访存。

​              \2. 如果该表项的有效位为0，则产生缺页中断，从辅存中调入该页，并修改段表

 

​     \3. 段页式存储

​        \1. 基本原理：段页式存储组织是分段式和分页式结合的存储组织方法，用分段方法来分配和管理虚拟存储器，

​                   用分页方法来分配和管理实存，这样可充分利用分段管理和分页管理的优点

 

​        \2. 地址转换

​            [![img](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190824114556563-1467815522.jpg)](https://img2018.cnblogs.com/blog/1610676/201908/1610676-20190824114556563-1467815522.jpg)

​          物理地址：基地址x、段号s、页号p和页内地址d，求物理地址(((x)+s)+p)*2^(11)+d  

 

​     \4. 页面置换算法

 

  考点3：文件管理

​      \1. 绝对路径和相对路径

​         \1. 绝对路径：从根目录开始写起，文件的全名为绝对路径+文件名

​         \2. 相对路径：从当前位置下一级目录开始写起

 

​      \2. 索引文件

​        \1. 地址向个数：物理块大小/地址项长度，向下取整

​        \2. 直接索引，文件大小为 物理盘块大小×索引节点数。

​        \3. 一级间接索引，文件大小为 物理盘块大小×索引节点数的次幂。

​        \4. 二级间接索引，文件大小为 物理盘块大小×索引节点数的次幂。

​          [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190905195726848-1669929092.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190905195726848-1669929092.png)          

 

​      \3. 位示图       

​        \1. 对于位示图，每一个bit位可以表示一个磁盘的占用情况，“0”表示空闲，“1”表示占用。

​        \2. 对于字的长度与具体机器字长有关，有题目指定，假设机器字长16位，则每个字可以表示16个磁盘块的占用情况；

​        \3. 指定序号为n或第n+1个磁盘，占用情况需要用m=(n+1)/16（向上取整）个字表示，字的序号为m-1。注意其中磁盘序号、字的序号、对应位号都是从0开始，计算过程中会有加1或减1处理。

 

​      \4. 磁盘管理

​        \1. 参数

​          \1. 磁头(head): 固定在可移动的机械臂上，用于读写数据。

​           \2. 磁道(track): 每个盘面都有 n 个同心圆组成，每个同心圆称之为一个磁道。

​           \3. 柱面(cylinder): n 个盘面的相同磁道 (位置相同) 共同组成一个柱面。

​           \4. 扇区(sector): 扇区是硬盘的最小组成单元，通常是 512 字节。磁道上的扇区数最大为 63 (6 个二进制位)

 

​        \2. 计算

​           \1. 存储容量(单位统一)

​             \1. 非格式化容量：位密度 × 磁道最小周长(π×内径) × 磁道总数((外径 - 内径)÷ 2 ×道密度) × 面数

​             \2. 格式化容量：扇区容量 × 扇区数 × 每面磁道数 × 面数

 

​           \2. 数据传输速率：每磁道存储的用户信息总数目(扇区数 × 每扇区的字节数) × 每秒钟磁盘转动圈数

​            \3. 存取时间=寻道时间+等待时间，寻道时间是指磁头移动到磁道所需的时间；等待时间为等待读写的扇区转到磁头下方所用的时间。有时还需要加上数据的传输时间

 

​         \3. 磁盘调度算法

​           \1. 先来先服务FCFS（谁先申请先服务谁）

​           \2. 最短寻道时间优先SSTF（申请时判断与磁头当前位置的距离，谁短先服务谁）

​           \3. 扫描算法SCAN（电梯算法，双向扫描）

​           \4. 循环扫描CSCAN（单向扫描）

 

  考点4：设备管理

​     \1. I/O传输控制方式

​        \1. 程序查询方式：CPU一直处于询问、等待的过程，占用CPU时间最长，CPU利用率最低

​        \2. 中断方式：I/O完成后向CPU发送中断请求信号，CPU和I/O可以并行

​        \3. DMA方式：CPU只做初始化，不参与具体数据传输过程

 

​     \2. 虚设备与SPOOLING技术

​        \1. 概念：

​        \2. 应用场景

​        \3. 技术过程

​           [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190907160901327-1287461661.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190907160901327-1287461661.png)

   

**第三章：数据库系统**

  **考点1：数据库模式**

​     \1. 三级模式

​        \1. 外模式：用户与数据库系统的接口，对应视图

​        \2. 概念模式：数据库中全部数据的整体逻辑结构描述，对应数据库表

​        \3. 内模式：数据库在物理存储方面的描述，包括定义的内部数据类型、索引、文件的组织方式，对应物理文件

 

​     \2. 两级映射

​        \1. 外模式-概念模式：存在于外部级和概念级之间，实现了外部模式到概念模式之间的相互转换

​        \2. 概念模式-内模式：存在于概念级3和内部级之间，实现了概念模式到内部模式之间的相互转换

​        \3. 作用：保证数据库中的数据具有较高的逻辑独立性和物理独立性

 

​     \3. 数据独立性

​        \1. 逻辑独立性：逻辑结构发生改变时，用户程序对外模式的调用可以不做修改

​        \2. 物理独立性：数据库的内模式发生改变时，数据的逻辑结构不变

 

  **考点2：ER模型（内部实体之间有联系）**

​     \1. ER图各元素的定义

​        \1. 实体：现实世界中可以区别于其他对象的“事件”或“物体”，用矩形表示

​        \2. 弱实体：与依赖的实体以带圆形的线连接，与实体有很强的依赖关系，单独存在没有意义，用双边矩形表示

​        \3. 属性：实体的特性，体现为表中的属性列名，用椭圆表示

​        \4. 联系：反应实体与实体之间的联系，用菱形表示

​           [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909193809146-1530117417.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909193809146-1530117417.png)

 

  **考点3：关系代数**

​     \1. 并：结果为二者元组之和去除重复行

​     \2. 交：结果为二者重复行

​     \3. 差：前者去除二者重复行

​         [![关系代数](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909195200129-45471867.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909195200129-45471867.png)

 

​     \4. 笛卡尔积：结果列数为二者属性列数之和，行数为二者元素数乘积

​     \5. 投影：对属性列的选择列出

​     \6. 选择：对元素行的选择列出

​          [![关系代数](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909195241844-1898969118.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909195241844-1898969118.png)

 

​     \7. 自然连接：结果列数为二者属性列数之和减去重复列，行数为二者同名属性列其值相同的结果元组。笛卡尔积、选择、投影的组合表示可以与自然连接等价

​         [![关系代数](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909195418375-1696306960.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909195418375-1696306960.png)

 

  **考点4：规范化理论**

​     \1. 键的求取

​        \1. 候选键（候选码）是能够唯一标识元素却无冗余的属性组合，可以有多种不同的候选键，在其中任选一个作为主键。候选键的求取可以利用图示法找入度为0的属性集合，并在此基础上进行扩展，最终找到能够遍历全图的最小属性组合作为候选键，对于入度为0在关系依赖集中可以理解为从未在箭线右侧出现。

​         \2. 组成候选码的属性就是主属性，其他为非主属性。

​        \3. 外键是其他关系模式的主键。

 

 

​     \2. 范式

​        \1. 第一范式（1NF）：在关系模式R中，当且仅当所有域只包含原子值，即每个属性都是不可再分的数据

​        \2. 第二范式（2NF）：当且仅当关系模式R是第一范式（1NF），且每一个非主属性完全依赖候选键（没有不完全依赖）时

​        \3. 第三范式（3NF）：当且仅当关系模式R是第二范式（2NF），且R中没有非主属性传递依赖于候选键时

​        \4. BC范式（BCNF）：设R是一个关系模式，F是它的依赖集，R属于BCNF当且仅当其F中每个依赖的决定因素必定包含R的某个候选码

​             [![范式](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909201355996-1083068978.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909201355996-1083068978.png)

 

 

​     \3. 规范化过程

​        \1. 保持函数依赖：设数据库模式ρ={R1，R2，…，Rk}是关系模式R的一个分解，F是R上的函数依赖集，ρ中每个模式Ri上的FD集是Fi。如果{F1，F2，…，Fk}与F是等价的（即相互逻辑蕴涵），那么称分解ρ保持FD。

​        \2. 无损联接分解：指将一个关系模式分解成若干个关系模式后，通过自然联接和投影等运算仍能还原到原来的关系模式。（表格法，公式法-仅限分解为2个子关系）

 

  **考点5：SQL语言**

​     \1. 数据表操作
​        \1. 创建数据表：create table 表名(
​                      字段名 数据类型 [非空约束][auto_increment]
​                      primary key(字段名)
​                      constraint 外键名 foreign key(字段名) references 主表名(主键)

​                     );

​        \2. 修改表名：alter table 旧表名 rename 新表名
​        \3. 修改字段名：alter table 表名 change 旧字段名 新字段名 新数据类型;
​        \4. 修改字段数据类型：alter table 表名 modify 字段名 数据类型;
​        \5. 添加字段：alter table 表名 add 字段名 数据类型
​        \6. 删除字段：alter table 表名 drop 字段名;
​        \7. 删除外键约束：alter table 表名 drop foreign key 外键名
​        \8. 删除表：drop table 表名

​     \2. 表数据的增删改
​       \1. 增加数据：insert into 表名(字段1，字段2,...) values(值1，值2,...)
​       \2. 删除数据：delete from 表名 where 表达式
​        \3. 修改数据：update 表名 set 字段=新值 where 表达式

​    \3. 查询数据

​       [![数据查询](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909202626779-973326940.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909202626779-973326940.png)  

 

  **考点6：并发控制**

​     \1. 事务特性

​        \1. 原子性：事务是原子的，要么都做，要么都不做

​        \2. 一致性：事务执行的结果必须保证数据库从一个一致性状态变到另一个一致性的状态

​        \3. 隔离性：事务相互隔离，当多个事务并发执行时，任一事务的更新操作直到其成功提交的整个过程，对其他事务都是不可见的

​        \4. 持续性：一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效

 

 

​     \2. 并发产生的问题

​         [![并发产生的问题](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909203706186-1172384092.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190909203706186-1172384092.png)

 

​     \3. 封锁协议

​        \1. 共享锁（S锁）：若事务T对数据对象A添加了S锁，则只允许T读取A，但不能修改A。并且其他事务只能对A加S锁，不能加X锁

​        \2. 排他锁（X锁）：若事务T对数据对象A添加了X锁，则只允许T读取和修改A，其他事务不能再对A加任何锁

 

  **考点7：数据库完整性约束**

​     \1. 实体完整性：规定其主属性不能去空值

​     \2. 参照完整性（也称为引用完整性）：规定其外键为参照表的主键值或为空值

​     \3. 用户自定义完整性(函数)：用户针对某一具体的关系数据库的约束条件

​     \4. 触发器：一种复杂的完整性约束。

 

 

**第四章：计算机网络与信息安全**

  **考点1：七层模型**

​         [![七层模性](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911122439943-38661666.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911122439943-38661666.png)

 

  **考点2：TCP/IP协议族（★★★★）**

​     \1. TCP/IP协议层次模型

​         [![协议组](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911122549422-1865656098.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911122549422-1865656098.png)

​     \2. 常见协议功能和端口号       

​         POP3：110端口，邮件收取

​         SMTP：25端口，邮件发送

​         FTP：20数据端口/21控制端口，文件传输协议

​         HTTP：80端口，超文本传输协议，网页传输

​         DHCP：67端口，IP地址自动分配

​         SNMP：161端口，简单网络管理协议

​         DNS：53端口，域名解析协议，记录域名与IP的映射关系

​         TCP：可靠的传输层协议

​         UDP：不可靠的传输层协议

​         ICMP：因特网控制协议，PING命令来自该协议

​         IGMP：组播协议

​         ARP：地址解析协议，IP地址转换为MAC地址

​         RARP：反向地址解析协议，MAC地址转IP地址

 

 

  **考点3：IP地址与子网划分**

​     \1. IP地址分类

​        \1. A类地址：网络号8位，0开始

​        \2. B类地址：网络号16位，10开始

​        \3. C类地址：网络号24位，110开始

​        \4. D类地址：组播地址，1110开始

​        \5. E类地址：保留地址，11110开始

​     

​      \2. IP地址的计算

​      \3. 子网划分：将一个网络划分成多个子网（取部分主机号当子网号）

​      \4. 路由汇聚：将多个网络合并成一个大的网络（取部分网络号当主机号

 

 

  **考点4：网络规划与设计**

​         **[![网络规划与设计](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911124459546-71742410.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911124459546-71742410.png)**

 

  **考点5：3G/4G标准**

​         **[![无线](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911125206513-242480002.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911125206513-242480002.png)**

 

  **考点6：\**对称加密与非对称加密\****

​    1.对称加密：加密与解密使用同一秘钥

​       \1. 特点：

​          1、加密强度不高，但效率高；

​          2、密钥分发困难

​       \2. 常见对称密钥加密算法：DES、 3DES(三重DES)、 RC-5、IDEA、AES算法

 

​    \2. 非对称加密：密钥必须成对使用，公钥加密，相应的私钥解密

​       \1. 特点：加密速度慢，但强度高

​       \2. 常见非对称密钥加密算法： RSA、ECC

 

  

  **考点7：信息摘要与数字签名**

​     \1. 数字签名的过程如下图所示（发送者使用自己的私钥对摘要签名，接收者利用发送者的公钥对接收到的摘要进行验证）

​         [![数字签名过程](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911130721569-1096673759.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911130721569-1096673759.png)

​     \2. 常见的摘要算法：MD5(128位)，SHA(160位)

 

  **考点8：数字证书**

​     \1. 数字证书的内容包括：CA签名、用户信息（用户名称）、用户公钥等。

​     \2. CA签名验证数字证书的可靠性。

​    \3. 用户公钥：客户端利用证书中的公钥加密，服务器利用自己的私钥解密。

 

  **考点9：网络安全协议**

​      \1. 安全协议分层

​         [![安全协议](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911160933770-1364554508.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911160933770-1364554508.png)

 

​     \2. 协议内容

​        \1. HTTPS协议是HTTP协议与SSL协议的结合，默认端口号443

​        \2. PGP协议是邮件安全协议

​        \3. SET协议是电子商务安全协议，涉及电子交易安全

 

   **考点10：防火墙技术与网络攻击**

​      \1. 网络攻击分类

​          [![网络攻击分类](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911161430885-1951701800.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190911161430885-1951701800.png)

 

​      \2. 常见的攻击行为

​         \1. 拒绝服务：攻击者利用众多傀儡主机向服务器发送服务请求，导致服务器资源被耗尽，无法提供正常的服务，向其他访问者发送拒绝服务应答

​         \2. 重放攻击：攻击者抓取向服务器发送的有效数据包，并利用此数据包不断地向服务器发送，导致服务器一直应答此数据包，从而崩溃

​         \3. 业务流分析：通过长期监听被攻击者的数据流，从而分析出相关业务流，可以依此了解被攻击者的一些倾向，常见的广告推送就是建立在业务流分析基础上的

 

​      \3. 常见的防御手段

​         \1. 防火墙技术：主要了解它的机制是防外不防内，对于DMZ非军事区主要放置应用服务器（如邮件服务器，WEB服务器）

​         \2. 漏洞扫描：入侵者可以利用系统漏洞侵入系统，系统管理员可以通过漏洞扫描技术，及时了解系统存在的安全问题，并采取相应措施来提高系统的安全性

​         \3. 入侵检测IDS：基于数据源的分类-审计功能、记录安全性日志。基于检测方法-异常行为检测而分析出相关业务流，可以依此了解被攻击者的一些倾向，常见的广告推送就是建立在业务流分析基础上的。

 

   **考点11：计算机病毒与木马**

​      \1. 常见的病毒、木马命名

​        \1. 系统病毒（KCOM）

​        \2. 蠕虫病毒（Worm）：红色代码，爱虫病毒，熊猫烧香，Nimda病毒、爱丽滋病毒；

​        \3. 木马病毒（Trojan）：通过远程网络进行控制的恶意程序

​        \4. 脚本病毒（Script）：

​        \5. 宏病毒（Macro）：

​     

​     \2. 常见的病毒分类

​        \1. 文件型计算机病毒感染可执行文件（包括EXE和COM文件）

​        \2. 引导型计算机病毒影响软盘或硬盘的引导扇区

​        \3. 目录型计算机病毒能够修改硬盘上存储的所有文件的地址

​        \4. 宏病毒感染的对象是使用某些程序创建的文本文档、数据库、电子表格等文件

 

**第五章：\**多媒体基础\****

  ***\*考点\**1. 音频**

​     \1. 声音

​       \1. 声音数字化过程：采样→ 量化→ 编码

​          \1. 计算机通过话筒收到的信号是音频模拟信号

​          \2. 数字音乐合成技术为FW和Wave Table

​            \1. FW中改变数字载波频率可以改变乐音的音调，改变信号幅度可以改变乐音的音高

​            \2. Wave Table：音质更好

​           \3. 声音信号数字化过程首先要进行的是A/D转换

 

​        \2. 声音格式

​          \1. wav：微软公司发布的音频文件格式, Windows系统使用的标准音频文件格式。记录音乐的模拟信号的采样数值。质量高，数据量大。

​           \2. mod：乐谱和乐曲使用的各种音色样本

​          \3. mp3：最流行的音频文件格式

 

​      \2. 视频

​        \1. 视频格式

​           \1. gif：用于网络传输

​           \2. avi：微软公司发布的视频文件格式（AVI文件）

​           \3. mov/qt：Apple公司发布的视频文件格式，较小存储空间，开放性（Quick Time文件）

​           \4. rm/rmvb：Real Networks公司格式，影像实时传输与播放（RealVideo文件）

​           \5. mpeg/mpg/dat/mp4：运动图像压缩标准，压缩效率高，质量好，兼容性好

​           \6. fli / foc：Autodesk公司出品答得彩色动画文件格式（Flic文件）

 

  ***\**\*考点\*\**\*2. 图像**

​     \1. 基本参数

​        \1. 亮度：画面的明亮程度

​        \2. 色调：颜色的种类

​        \3. 饱和度：色彩的纯洁性，即颜色的艳丽程度

​        \4. 显示分辨率：显示屏上能够显示的像素数目，1024*768表示显示屏分为768行（垂直分辨率），每行（水平分辨率）显示1024个像素

​        \5. 图像分辨率：一幅图像的像素密度，每英寸多少点（dpi）表示图像大小 ；200dpi扫描一幅2*2.5英寸的照片，则可以得到400*500像素点的图像

​        \6. 图像深度：存储每个像素所用的二进制数，度量图像的色彩分辨率，图像深度为b位，则该图像最多的颜色数或灰度级为2b种

​        \7. DPI：每英寸像素点数。（在二维计算中，需要行、列分别乘一次。）

​        \8. 彩色空间：RGB(普通显示器)、YUV(电视，兼容)、CMY/CMYK(印刷)、HSV/HSB(艺术家)

 

​     \2. 图像格式

​        \1. bmp：windows标准位图文件格式

​        \2. gif：用于网络传输，数据块为单位传输信息，采用无损压缩算法

​        \3. png：作为GIF替代品

​        \4. jpg：有损压缩，压缩比例高，适合于处理大量图像的场合

 

​      \3. 计算

​        \1. 音频的计算：每秒容量=采样频率(Hz)×量化/采样位数(位)×声道数÷8

​        \2. 视频的计算：容量=每帧图像容量(Byte) ×每秒帧数×时间+音频容量×时间

​        \3. 图像的计算：

​            [![图像计算](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190914183447998-1750344030.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190914183447998-1750344030.png)

 

  **考点3. 种类**

​     \1. 多媒体定义

​        \1. 传播信息的载体，如语言、文字、图像、视频、音频等；

​        \2. 存贮信息的载体，如ROM、RAM、磁带、磁盘、光盘等

 

​     \2. 多媒体的分类

​        \1. 感觉媒体：直接用于人的感觉器官，使人产生直接感觉的媒体。如：声音、图形、图像、动画等

​        \2. 表示媒体：传输感觉媒体的中介媒体，用于数据交换的编码。如文本编码、图像编码和声音编码等

​        \3. 表现媒体（显示媒体）：进行信息输入输出的媒体。如：输入显示媒体键盘、鼠标和麦克风等；输出显示媒体显示器、打印机和音箱等。

​        \4. 存储媒体：用于存储表示媒体的物理介质。如磁盘、光盘和内存等。

​        \5. 传输媒体：传输表示媒体的物理介质。如电缆、光缆和交换设备等。

 

​     \3. 多媒体标准

​        [![多媒体标准](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190914190758932-482453379.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190914190758932-482453379.png)

 

  **考点 4. 数据压缩技术**

​     \1. 压缩分类

​       \1. 有损压缩：也称为熵压缩法，压缩之后不能还原，如图片压缩成jpg格式

​       \2. 无损压缩：也称冗余压缩法或熵编码法，压缩后能够还原，如zip压缩格式

 

**第六章：\**程序设计语言\****

  ***\*考点\**1. 编译与解释（★★★）**

​      \1. 解释程序(解释器)：直接解释执行源程序(程序不独立)，解释程序(控制权)和源程序都要参与到程序的运行过程，边解释边执行，执行效率较低

​      \2. 编译程序(编译器)：将源程序翻译成目标语言程序(独立程序)，源程序和编译程序都不再参与目标程序的执行过程，执行效率较高。

​      \3. 编译过程

​         [![编译过程](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915154033142-1389578550.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915154033142-1389578550.png)

​        \1. 词法分析阶段：依据语言的词法规则将源程序逐个字符扫描，识别出一个个“单词”符号

​        \2. 语法分析阶段：依据语言的语法规则将单词符号序列分解成各类语法单位。如“表达式”、“语句”等

​        \3. 语义分析阶段：进行源程序类型分析并产生代码和检查是否包含静态语义错误

​        \4. 中间代码生成：根据语义分析的输出生成中间代码，常有树、后缀式、三地址码（四元式）

​        \5. 目标代码生成：把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码，与具体机器密切相关

​        \6. 符号表：记录源程序中各个符号的必要信息，辅助语义的正确性检查和代码生成，可以贯穿编译所有阶段

 

  **考点2. 文法（★★）**

​     \1. 概念： 一个形式文法是一个有序四元组G=(V，T，S，P)

​        V(非终结符)：大写字母，可以推导

​        T(终结符)：小写字母

​        S(起始符)：最开始

​          P(产生式)：用终结符替代非终结符的规则。形如α→β

 

​      \2. 文法的分类

​        [![文法的分类](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915162220515-1226036299.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915162220515-1226036299.png)

 

​       \3. 文法与语法树的推导：例：文法G=（{a, b}, {S, A}, S, P），其中：S→aAS|a；A→SbA|SS|ba。请构造句型aabAa的推导树。S → aAS； S → a； A → SbA；A → SS； A → ba

​         [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915162435916-2074831024.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915162435916-2074831024.png)

​       

  **考点3. 正规式（★★★★）**

​     \1. 对于字母表∑，其上正规式及其表示的正规集定义

​       \1. ε是一个正规式，它表示集合L(ε)={ε}

​       \2. 若a是∑上的字符，则a是一个正则式，它所表示的正规L(a)={a}

​       \3. 若正规式 r 和 s 分别表示正规集L(r)=L(s)，则

​          \1. r|s是正规式，表示集合L(r)∪L(s)

​          \2. r·s是正规式，表示集合L(r)L(s)

​          \3. r*是正规式，表示集合(L(r))*

​          \4. (r)是正规式，表示集合L(r)

​       \4. 仅由有限次地使用上述三个步骤定义的表达式才是∑上的正规式。闭包运算符“*”具有最高的优先级，连接运算“.”具有次高优先级，或运算符“|”具有最低优先级

 

​     \2. 常见正规式的含义

​        [![常见正规式的含义](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915163557195-581363047.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915163557195-581363047.png)

 

  **考点4. 有限自动机（★）**

​     \1. 字符串判断：一个有限自动机所识别的语言是从开始状态到终止状态所有路径上的字符串的集合

​        \1. 下图所示的有限自动机中，s0是初始状态，s3为终止状态，该自动机不能识别（）

​           A．abab    B．aaaa    C．babb     C．abba

​            [![图](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915170758110-442715001.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915170758110-442715001.png)

​           \1. 对于A：其识别路径为s0→s1→s2→s1→s2，字符串结束时的状态不是终止状态，所以该自动机不能识别“abab”

​          \2. 对于B：其识别路径为s0→s1→s3→s3→s3，字符串结束时的状态是终止状态，所以该自动机可以识别“aaaa”

​          \3. 对于C：其识别路径为s0→s2→s1→s2→s3，字符串结束时的状态是终止状态，所以该自动机可以识别“babb”

​          \4. 对于D：其识别路径为s0→s1→s2→s3→s3，字符串结束时的状态是终止状态，所以该自动机可以识别“abba”

​       

 、   2. 有限自动机转正规式

​        \1. 采用带入的方法

​        \2. 判断正规式的范围是否和有限自动机的范围相同

 

   **考点5. 表达式（★★★）**

​     \1. 前缀表达式(+ab)：把运算符写在运算对象的前面（语法树的先序遍历）

​     \2. 中缀表达式(a+b)：把运算符写在运算对象的中间（语法树的中序遍历）

​     \3. 后缀表达式(ab-)：又叫做逆波兰式，把运算符写在运算对象的后面（语法树的后序遍历）

​     \4. 例如：表达式(a - b) * ( c + 5)的后缀式是

​        \1. 画树：先画括号内的树，最后画括号外的树

​        \2. 遍历：先遍历左子树(从左到右在到上)，后遍历右子树(从左到右在到上)，最后遍历根节点

​      

 

   **考点6. 传值与传址（★★★★）**

​     \1. 比较

​        [![比较](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915171557103-1087624.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915171557103-1087624.png)

​     \2. 例题

​        [![例题](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915171656565-1975468864.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190915171656565-1975468864.png)

 

  **考点7. 多种程序语言特点（★★★）**

​     \1. 结构化程序设计语言

​       \1. Fortran语言：第一个高级程序设计语言，科学计算，执行效率高

​       \2. Pascal语言：表达能力强，Delphi

​       \3. C语言：通用，指针操作能力强，高效

​       \4. COBOL：数据处理领域最为广泛的程序设计语言，高级编程语言

​       \5. PROLOG：逻辑式语言，间接性，表达能力强，建造专家系统、数据库、自然语言理解、智能知识库等

​     \2. 面向对象程序设计语言

​       \1. C++：C语言基础上增加了类机制，高效，与C兼容，经常用来开发操作系统

​       \2. Java：中间代码，跨平台，通用的程序设计语言

​       \3. Python：解释型程序设计语言，胶水语言，通用的脚本语言

​     \3. 脚本语言：解释性语言

​       \1. PHP：服务器端脚本语言，制作动态网页

​       \2. Ruby：简单快捷、面向对象、脚本语言

​     \4. 函数式语言

​       \1. Lisp：函数式程序语言，符号处理，人工智能

 

**第七章：知识产权与标准化**

  **考点1：法律知识（★★）**

​     \1. 法律法规

​        [![法律法规](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190916125806107-1568840103.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190916125806107-1568840103.png)

​     \2. 作品保护期限

​         [![作品保护期限](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190916125909775-847042822.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190916125909775-847042822.png)

 

  **考点2：知识产权人确定（★★★）**

​     \1. 作品区分

​        [![作品职务](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190916130202395-1279369022.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190916130202395-1279369022.png)

​     \2. 作品归属

​        [![作品归属](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190916130240724-615672847.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190916130240724-615672847.png)

 

  **考点3：侵权判断（★★★★）**

​     \1. 判断

​        **[![侵权判断](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190916130455847-86858023.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190916130455847-86858023.png)**

 

​     \2. 特殊

​        \1. 中国公民、法人或者其他组织的作品，不论是否发表，都享有著作权。

​        \2. 开发软件所用的思想、处理过程、操作方法或者数学概念不受保护。

​        \3. 著作权不适用的情形：

​           \1. 法律、法规，国家机关的决议、决定、命令和其他具有立法、行政、司法性质的文件，及其官方正式译文

​           \2. 时事新闻、历法、通用数表、通用表格和公式

 

  **考点4：标准的分类及代号（★）**

​     \1. 国际标准：ISO、IEC等国际标准化组织。代号：标准代号+专业类号+顺序号+年代号

​     \2. 国家标准：GB—中国、ANSI—美国、BS—英国、JIS—日本。代号：我国强制性标准代号为GB、推荐性标准代号为GB/T、指导性标准代号为GB/Z、实物标准代号GSB

​     \3. 区域标准：又称为地区标准，如PASC—太平洋地区标准会议、CEN—欧洲标准委员会、ASAC—亚洲标准咨询委员会、ARSO—非洲地区标准化组织

​     \4. 行业标准：GJB—中国军用标准、MIT-S—美国军用标准、IEEE—美国电气电子工程师协会。代号：由汉语拼音大写字母组成

​     \5. 地方标准：国家的地方一级行政机构制订的标准。代号：由DB加上省级行政区代码的前两位

​     \6. 企业标准：代号由Q加上企业代号组成

 

**第八章：系统开发**

  **考点1：开发模型（★★★★★）**

​     \1. 瀑布模型：阶段明确，包括需求分析、设计、编码、运行与维护。一旦需求变，整个项目推倒重新开始。适用于需求明确或二次开发的项目

​      \2. V模型：强调测试贯穿项目始终

​     \3. 喷泉模型：面向对象模型，特点是迭代、无间隙。

​     \4. 原型模型：适用于需求不明确的场景(需求分析阶段)

​     \5. 增量模型：结合了瀑布模型和原型模型，在完成核心功能的基础上，每轮迭代会都会产生新的增量来强化核心功能

​     \6. 螺旋模型：结合了瀑布模型和演化模型的优点，最主要的特点在于加入了风险分析

 

  **考点2：软件开发过程（★）**

​     \1. 需求分析：软件要完成的功能及性能要求

 

​        \1. 功能需求：考虑系统要做什么，在何时做，在何时以及如何修改或升级。

​        \2. 性能需求：存储容量限制、执行速度、响应时间及吞吐率等性能指标。

​        \3. 设计约束：操作系统限制、开发语言限制等。

 

​     \2. 概要设计：确定软件的模块划分，包括系统架构、模块划分、系统接口及数据设计

​     \3. 详细设计：数据结构和算法设计

​     \4. 编码：代码编写和单元测试

​     \5. 软件复杂性度量参数

​        \1. 规模：指令数或源程序行数

​        \2. 难度：程序中出现的操作数

​        \3. 结构：程序结构

​        \4. 智能：算法的难易程度

 

   **考点3：系统设计（★★）**

​    \1. 系统设计的原则：高内聚、低耦合

​       \1. 内聚性

​         \1. 偶然聚合：模块完成的动作之间没有任何关系

​           \2. 逻辑聚合：模块内部的各个组成在逻辑上具有相似的处理动作，但功能用途上彼此无关。

​           \3. 时间聚合：模块内部的各个组成部分所包含的处理动作必须在同一时间内执行。

​           \4. 过程聚合：模块内部各个组成部分所要完成的动作虽然没有关系，但必须按特定的次序执行。

​           \5. 通信聚合：模块的各个组成部分所使用同一个数据或产生同一输出数据。

​           \6. 顺序聚合：模块内部的各个部分，前一部分处理动作的最后输出是后一部分处理动作的输入。

 

​       \2. 耦合性

​         \1. 功能聚合：模块内部各个部分全部属于一个整体，并执行同一功能，且各部分对实现该功能都比不可少

​         \2. 非直接耦合：两个模块之间没有直接关系，它们的联系完全是通过主模块的控制和调用来实现的。

​         \3. 数据耦合：两个模块彼此间通过数据参数交换信息。

​         \4. 标记耦合：一组模块通过参数表传递记录信息，这个记录是某一个数据结构的子结构，而不是简单变量。

​         \5. 控制耦合：两个模块彼此间传递的信息中有控制信息。

​         \6. 外部耦合：一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息。

​         \7. 公共耦合：两个模块之间通过一个公共的数据区域传递信息。

​         \8. 内容耦合：一个模块需要涉及到另一个模块的内部信息。

 

​     2.

 

  **考点4：软件测试（★★★★）**

​     \1. 测试方法分类

​        [![测试方法](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190917170132516-1380251484.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190917170132516-1380251484.png)

 

​     \2. 黑盒测试方法：不知道内部结构

​        \1. 等价类划分：确定无效与有效等价类，设计用例尽可能多的覆盖有效类，设计用例只覆盖一个无效类

​        \2. 边界值分析：处理边界情况时最容易出错，选取的测试数据应该恰好等于、稍小于或稍大于边界值

​     \3. 白盒测试方法：知道内部结构

​        \1. 语句覆盖：程序的每个语句(判断和赋值)至少执行一次

​        \2. 判定覆盖：每个语句至少执行一次，而且每个判定的真假分支都至少执行一次

​        \3. 条件覆盖：每个语句至少执行一次，而且判定表达式中的每个条件都取得各种可能的结果

​        \4. 判定/条件覆盖：同时满足判定覆盖和条件覆盖的逻辑覆盖

​         \5. 路径覆盖：选取足够多的测试用例，使得程序的每条可能执行到的路径都至少经过一次

​     \4. 各测试阶段任务

​        \1. 单元测试：模块接口、局部数据结构、边界条件、独立的路径、错误处理。

​        \2. 集成测试：模块间的接口和通信。

​        \3. 系统测试：恢复测试、安全性测试、强度测试、性能测试、可靠性测试和安装测试。

​        \4. 验收测试：有效性测试、软件配置审查、验收测试。

​        \5. 回归测试：修改软件后进行的测试，防止引入新的错误。

​      \5. McCabe复杂度计算：V(G)=m-n+2，其中m是有向边的条数，n是结点数

​     

  **考点5：软件维护（★★★★）**

​     \1. 正确性维护：针对真实存在并已经发生的错误进行的维护。

​     \2. 预防性维护：针对真实存在但还未发生的错误进行的维护。

​     \3. 适应性维护：指使应用软件适应信息技术变化和管理需求变化而进行的修改。企业的外部市场环境和管理需求的不断变化也使得各级管理人员不断提出新的信息需求。

​     \4. 完善性维护：扩充功能和改善性能而进行的修改。对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征

​     [![软件质量保证](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190917171821505-1705740997.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190917171821505-1705740997.png)

 

  **考点6：软件过程改进（★★）**

​     \1. 统一过程（UP、RUP）：典型特点是用例驱动、以架构为中心、迭代和增量，四个阶段：

​        \1. 初启阶段：项目的初创活动，里程碑是生命周期目标

​        \2. 精化阶段：需求分析和框架演进，里程碑是生命周期架构

​        \3. 构建阶段：系统的构建，产生实现模型，里程碑是初始运作功能

​        \4. 移交阶段：将产品发布给用户进行测试评价，并收集用户的意见，产生软件增量，里程碑是产品发布

 

​     \2. 敏捷开发：是一种以人为核心、迭代、循序渐进的开发方法，适用于小团队和小项目，具有小步快跑的思想

​        \1. 极限编程

​          \1. 四大价值观：沟通、简单、反馈、勇气

​          \2. 五大原则：快速反馈、简单性假设、逐步修改、提倡更改、优质工作

​          \3. 十二个最佳实践

​             \1. 计划游戏：快速制定计划、随着细节的不断变化而完善

​             \2. 隐喻：找到合适的比喻传达信息

​             \3. 小型发布：系统的设计能够尽可能早的交付

​             \4. 简单设计：只处理当前的需求使设计保持简单

​             \5. 测试先行：先写测试代码在编程

​             \6. 重构：重新审视需求和设计，以符合新的和现有的需求

​        \2. 水晶法：强调经常交付，认为每一种不同的项目都需要一套不同的策略、约定和方法论

​        \3. 并列争球法：核心是迭代、增量交付，按照30天进行迭代开发交付可实际运行的软件

​        \4. 自适应软件开发：核心是三个非线性的，重迭的开发阶段：猜测、合作、学习

 

​     \3. 软件能力成熟度模型

​        \1. CMM：5个级别

​          \1. 初始级(第1级)：混乱和不可预测

​          \1. 重复级(第2级)：建立基本的项目管理过程和实践来跟踪项目经费、进度和功能特性

​          \2. 定义级(第3级)：组织具有标准软件过程

​          \3. 管理级(第4级)：对软件过程的产品都有定量的理解与控制

​          \4. 优化级(第5级)：过程的量化反馈和先进的新思想、新技术促使过程不断改进

 

​        \2. CMMI：6个级别

​          \1. 未完成级(第0级)：过程域的目标未满足

​          \2. 已执行级(第1级)：完成过程域的目标

​          \3. 已管理级(第2级)：针对单个过程实例的能力

​          \4. 已定义级(第3级)：过程的组织级标准化和部署

​          \5. 定量管理级(第4级)：过程定量管理

​          \6. 优化管理级(第5级)：过程不断的改进

​           [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190917172143062-1547625254.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190917172143062-1547625254.png)

 

​       \3. 连续式模型

​          \1. CL0（未完成的）：过程域未执行或未得到CL1中定义的所有目标。

​           \2. CL1（已执行的）：其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标。

​          \3. CL2（已管理的）：其共性目标是集中于已管理的过程的制度化。根据组织级政策规定过程的运作将使用哪个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制、和评审。

​          \4. CL3（已定义级的）：其共性目标集中于已定义的过程的制度化。过程是按照组织的裁剪指南从组织的标准过程中裁剪得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进。

​          \5. CL4（定量管理的）：其共性目标集中于可定量管理的过程的制度化。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的质量目标作为管理准则。

​           \6. CL5（优化的）：使用量化（统计学）手段改变和优化过程域，以满足客户的改变和持续改进计划中的过程域的功效。

 

  **考点7：项目管理**

​     \1. Gantt图和PERT图

​        \1. 甘特图：难以反映多个任务之间存在的逻辑关系

​        \2. PERT图：不能清晰的描述各个任务之间的并行关系

​        \3. 计算

​          \1. 关键路径：图中源点至汇点的最长路径，关键路径的时间称之为项目工期，也表述为项目完成所需的最少时间

​          \2. 总时差(松弛时间)：最晚结束时间减去最早结束时间，或以最晚开始时间减去最早开始时间求取 

​          \3. 最早开始时间：顺推

​          \4. 最晚开始时间：逆推

 

​     \2. 风险管理

​        \1. 风险的特性：具有不确定性，可能会造成损失。

​        \2. 风险分析

​          \1. 风险识别：系统化的确定项目风险的威胁

​          \2. 风险预测：风险发生的可能性或概率

​          \3. 风险评估：根据风险发生的概率和产生的影响预测是否影响参考水平值

​          \4. 风险控制：辅助项目组建立处理风险的策略，有效的策略应该考虑风险避免(最有效)、风险监控、风险管理及意外事件计划

​        \3. 风险类别

​          \1. 项目风险：预算、进度、人员、资源以及和客户相关的问题

​          \2. 技术风险：设计、实现、对接、及维护问题

​          \3. 商业风险：市场风险、策略凤险、管理风险和预算风险

​        \4. 项目估算方法

​          \1. 专家判断方法：受专家经验和主观性影响

​          \2. 算法方法：模型中的参数难以确定

​          \3. 机器学习方法：难以定义训练数据的特征以及定义数据对象之间的相似性

​       \5. 风险曝光度 = 风险出现率 X 风险损失

 

​      \3. 文档知识

​        \1. 系统开发计划：用于系统开发人员和项目管理人员在项目期内进行沟通，包括工作任务分解表、PERT图、甘特图和预算分配表

​        \2. 总体规划和开发合同：用于与系统分析人员在系统规划和系统分析阶段的沟通

​        \3. 测试计划：用于系统测试人员与系统开发人员之间的沟通

​        \4. 特点

​           \1. 针对性：文档编制应考虑读者对对象群体

​           \2. 精确性：文档的行文应该十分确切，不能出现多一性的描述

​           \3. 完整性：任何文档都应该是完整的、独立的，应该自成体系

​           \4. 灵活性：各个不同软件项目的规模和复杂程度存在差距，不能一律看待

​           \5. 追溯性：各个开发阶段编制的文档与各个阶段完成的工作有密切关系，所以在一个项目各个开发阶段之间提供的文档必定存在着可追溯关系

 

**第九章：\**数据结构与算法\****

  ***\*考点1：矩阵\****

​     \1. 数组

​        [![数组](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925143402614-531038885.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925143402614-531038885.png)

 

​     \2. 矩阵：计算时采用带点排除法，注意一维数组的起始位置

​        [![矩阵](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925143418086-1569780586.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925143418086-1569780586.png)

 

 

  ***\*考点2：表\****

​      \1. 线性表

​        \1. 顺序表：顺序存储，即用一组地址连续的存储单元依次存储线性表中的数据元素

​        \2. 链表：链式存储，即通过指针链接起来的结点来存储数据元素

​          \1. 单链表：每个结点中除包含数据域外，只设置一个指针域用以指向其直接后继结点

​             [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925212400806-1197903511.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925212400806-1197903511.png)

​          \2. 双链表：每个结点中除包含数值域外，设置两个指针域，分别用以指向直接前驱结点和直接后继结点

​              [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925212422844-1529821878.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925212422844-1529821878.png)

​          \3. 循环链表：头结点的指针域指向尾结点的指针域

​              [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925212827043-153235976.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925212827043-153235976.png)

​          [![线性表](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925144454212-967010818.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925144454212-967010818.png)

​        \3. 队列(先进先出)和栈(先进后出)

​          \1. 循环队列

​               \1. 队空条件：head=tail；

​             \2. 队满条件：(tail+1)%size=head

​           \2. 解题技巧

​             \1. 按照一定顺序输入栈，那么出栈的可能有很多，因为进去的同时就立马出去

​             \2. 队列和栈结合时，将选项带入，使用两者的规则进行选择

 

​     \2. 广义表

​        \1. 广义表是n个表元素组成的有限序列，是线性表的推广，LS=(a0, a1,…, an)。

​        \2. 长度（最外层表(LS)含有多少个元素），深度（包含括号的重数）

​        \3. 取表头head(Ls)（最外层表的第一个元素），取表尾tail(Ls)（除了最外层表中第一个元素之外的其他所有元素）

 

  ***\*考点3：树\****

​    \1. 树与二叉树的特性

​       \1. 树的概念

​          \1. 孩子(结点的子树的根称为该结点的孩子)、双亲(该结点称为其子结点的双亲)、和兄弟(具有相同双亲的结点互为兄弟)

​          \2. 结点的度：一个结点的子树的个数

​          \3. 叶子节点(终端结点)：指度为0的结点

​          \4. 内部结点(分支节点)：指度不为0的结点

​          \5. 结点的层次：若某节点在第i层，则其孩子结点在第i+1层

​          \6. 树的深度：一颗树的最大层次数

 

​        \2. 二叉树的特性

​          \1. 在二叉树的第i层上最多有2i-1个结点（i≥1）；

​          \2. 深度为k的二叉树最多有2k -1个结点（k≥1）；

​          \3. 对任何一棵二叉树，如果其叶子结点数为n0，度为2的结点数为n2，则n0=n2+1。

​          \4. 如果对一棵有n个结点的完全二叉树的结点按层序编号（从第1层到 L log2n ˩+1层，每层从左到右），则对任一结点i（1≤i≤n），有：

​            \1. 如果i=1，则结点i无父结点，是二叉树的根；如果i>1，则父结点是L i/2 ˩ ；

​            \2. 如果2i>n，则结点i为叶子结点，无左子结点；否则，其左子结点是结点2i；

​            \3. 如果2i+1>n，则结点i无右子叶点，否则，其右子结点是结点2i+1。

 

​    \2. 特殊的二叉树

​       \1. 二叉树：二叉树是每个结点最多有两个孩子的有序数，可以为空树，可以只有一个结点。

​       \2. 满二叉树：任何结点恰有两棵非空子树。

​       \3. 完全二叉树：最多可以有两个叶子结点，并且都在左边

​       \4. 平衡二叉树：树中任一结点的左右子树高度之差不超过1

​       \5. 排序二叉树：任一结点的权值，大于其左孩子结点，小于其右孩子结点。

​       \6. 线索二叉树：在每个结点中增加两个指针域来存放遍历时得到的前驱和后继信息。

​       \7. 最优二叉树：又称为哈弗曼树，它是一类带权路径长度最短的树。

​         \1. 路径长度：从树根到每一个叶子结点的通路数目之和。

​         \2. 结点的带权路径长度：路径长度与该结点权值的乘积。

​         \3. 树的带权路径长度：树中所有叶子结点的带权路径长度之和。

​         \4. 哈弗曼树的构造

​            \1. 根据给定的权值集合，找出最小的两个权值，构造一棵子树最为其孩子结点，二者权值之和作为根结点

​            \2. 在原集合中删除这两个结点的权值，并引入根节点的权值

​            \3. 重复步骤（1）和步骤（2），直到原权值集合为空

 

​    \3. 树的遍历

​       \1. 先序遍历：按根à左à右的顺序进行遍历

​       \2. 后序遍历：按左à右à根的顺序进行遍历

​       \3. 中序遍历：按左à根à右的顺序进行遍历

​       \4. 层次遍历：按层次顺序进行遍历

 

  ***\*考点4：图\****

​     \1. 完全图

​        \1. 在无向图中，若每对顶点之间都有一条边相连，则称该图为完全图

​        \2. 在有向图中，若每对顶点之间都有二条有向边相互连接，则称该图为完全图

​      \2. 图的存储

​        \1. 邻接矩阵：具有对称性，存储时可以只存出其中一个三角

​           [![邻接矩阵](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925155905904-1549384805.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925155905904-1549384805.png)

 

 

​        \2. 邻接表：首先把每个顶点的邻接顶点用链表示出来，然后用一个一维数组来顺序存储上面每个链表的头指针

​           [![邻接表](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925155931364-821197380.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925155931364-821197380.png)

 

​      \3. 图的遍历

​         [![图的遍历](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925160231350-49039887.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190925160231350-49039887.png)

 

​      \4. 图的拓扑排序：在AOV网点中从顶点Vi到Vj用有向边表示活动开始的顺序

​      \5. 最小生成树

​        \1. 选择入度为0的顶点作为起点

​        \2. 选择顶点之间最短（代价最小）路径的几条边，不能形成环路

 

  ***\*考点5：算法基础及常见算法\****

​     \1. 算法的特性

​        \1. 有穷性：执行有穷步之后结束

​        \2. 确定性：算法中每一条指令都必须有确切的含义，不能含糊不清

​        \3. 输入（>=0），输出（>=1）

​        \4. 有效性(可行性)：算法的每个步骤都能有效执行并能得到确定的结果。例如a=0，b/a就无效

​     \2. 分治法

​         \1. 特征：把一个大问题拆分成多个小规模的相同子问题，一般可用递归解决。

​         \2. 经典问题：斐波那契数列、归并排序、快速排序、矩阵乘法、二分搜索、大整数乘法、汉诺塔

​      \3. 动态规划法（用于求最优解）

​        \1. 特征：划分子问题（最优子结构），并把子问题结果使用数组存储，利用查询子问题结果构造最终问题结果

​        \2. 经典问题：斐波那契数列、矩阵乘法、背包问题、 LCS最长公共子序列

​     \4. 回溯法（通用的解题法）

​        \1. 特征：包含问题的所有解的树中，按照深度优先的策略，从根节点出发搜索树。系统的搜索一个问题的所有解或任一解

​        \2. 经典问题：N皇后问题、迷宫、背包问题

​     \5. 贪心法（用于求满意解）

​        \1. 特征：局部最优，但整体不见得最优。每步有明确的，既定的策略

​        \2. 经典问题：背包问题（如装箱）、多机调度、找零钱问题

 

   **考点6：时间复杂度与空间复杂度（★★★★★）**

​      \1. 时间复杂度：程序运行从开始到结束所需要的时间

​        \1. 常见时间复杂度排序：O(1)<O(log2n)<O(n)<O(nlog2n)<O(n2)<O(n3)<O(2n)

​           \1. O(1)：单个语句，无循环

​           \2. O(n)~O(n3)：单层循环、双层嵌套循环、三层嵌套循环

​           \3. O(log2n)：树形结构、二分法、构建堆过程

​           \3. O(nlog2n)：堆排序、归并排序

​           \4. O(2n)：所有不同可能的排列组合

​        \2. 主定理求固定形式递归式的时间复杂度

​           [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928132623022-1672870318.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928132623022-1672870318.png)

 

​      \2. 空间复杂度：算法在运行过程中临时占用存储空间大小

 

  ***\*考点7：排序和查找\****

​     \1. 查找

​        \1. 顺序查找：将待查找的关键字依次与表中元素进行比较，时间复杂度为O(n)

​        \2. 二分法查找：比较次数最多为log2n +1 ，时间复杂度为 O(log2n)，

​         \1. 确定中点位置：mid=(low+high)/2

​         \2. 将待查的值K与R[mid].key比较

​           \1. 若R[mid].key＞k，新的查找区间是左子表，其中high=mid–1。

​           \2. 若R[mid].key< k，新的查找区间是右子表，其中low=mid+1。

​           \3. 若R[mid].key=k，则查找成功，算法结束。

​          \3. 例题：请给出在含有12个元素的有序表｛1，4，10，16，17，18，23，29，33，40，50，51｝中二分查找关键字17的过程。

​               [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928195756537-2063069202.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928195756537-2063069202.png)

 

​        \3. 散列表查找：已知关键字集合U，最大关键字为m，根据函数Hash的值存储到对应的空间

​          \1. 开放定址法：按照某种探测方法，逐个查找此地址中是否存储了数据元素，如果没有，将关键字存入，否则，继续查找下一个地址

​             \1. 线性探测法：将关键字存储在下一个没有被占的位置

​             \2. 伪随机数法：随机的将关键字存储在没有被占的位置

​          \2. 例题：记录关键码为（3，8，12，17，9），取m=10（存储空间为10），p=5，散列函数h=key%p

​             [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928201400030-56069307.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928201400030-56069307.png)

 

​      \2. 排序

​         [![排序分类](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928201517237-1843103666.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928201517237-1843103666.png)

 

​        \1. 直接插入排序

​           \1. 排序规则：第i个记录Ri依次与Ri-1，…，R2，R1进行比较，找到合适的位置插入

​           \2. 特点：效率低

​        \2. 希尔排序

​           \1. 排序规则

​             \1. 取一个小于n的整数d1将记录分成d1个组，距离为d1的倍数的记录放在同一个组中，各组内进行直接插入排序

​             \2. 取第二个增量d2<d1重复1步骤，直至所取的增量dt=1，将最后得到的组进行直接插入排序即可

​           \2. 特点：效率高

​             [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928205459583-1077872595.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928205459583-1077872595.png)

​        \3. 直接选择排序

​           \1. 排序规则

​              \1. 在所有记录中选出排序码最小的记录，把它与第1个记录交换

​              \2. 在其余的记录内选出排序码最小的记录，与第2个记录交换……依次类推，直到所有记录排完为止

​             [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928205536074-1420809549.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928205536074-1420809549.png)

​        \4. 堆排序

​           \1. 堆的定义：设有n个元素的序列{K1，K2，…，Kn}

​             \1. 若Ki ≤ K2i 且 Ki ≤ K2i +1，称为小顶堆

​             \2. 若Ki ≥ K2i 且 Ki ≥ K2i +1，称为大顶堆

​           \2. 排序规则：先将序列建立堆，然后输出堆顶元素，再将剩下的序列建立堆，然后再输出堆顶元素，依此类推，直到所有元素均输出为止

​              \1. 将顺序表R[1..n]中元素建立为一个堆，堆顶位于R[1]，待序区为R[1..n]

​              \2. 循环执行步骤3～步骤4，共n-1次

​              \3. 假设为第i 运行，则待序区为R[1..n-i+1]，将堆顶元素R[1]与待序区尾元素R[n-i+1]交换，此时顶点元素被输出，新的待序区为R[1..n-i ]

​              \4. 待序区对应的堆已经被破坏，将之重新调整为大顶堆

 

​        \5. 冒泡排序

​           \1. 排序规则：通过相邻元素之间的比较和交换，将排序码较小的元素逐渐从底部移向顶部

​             [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928234137961-1844848884.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928234137961-1844848884.png)

​        \6. 快速排序

​           \1. 排序规则：将原问题分解成若干个规模更小但结构与原问题相似的子问题。通过递归地解决这些子问题，然后再将这些子问题的解组合成原问题的解

​             \1. 在待排序的n个记录中任取一个记录作为基准

​             \2. 使用基准和最后一个元素作比较

​             \3. 然后用第二个元素和基准作比较，依次类推，最后基准在中间

​             [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928234554669-1175785592.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190928234554669-1175785592.png)

 

 

​        \7. 归并排序

​           \1. 排序规则

​             \1. 将两个或两个以上的有序子表合并

​             \2. 比较A[i]和A[j]的排序码大小，若A[i]的排序码小于等于A[j]的排序码，则将第一个有序表中的元素A[i]复制到R[k]中，并令i和k分别加1

​             \3. 如此循环下去，直到其中一个有序表比较和复制完，然后再将另一个有序表的剩余元素复制到R中

​              [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190929000031849-489662189.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190929000031849-489662189.png)

​        \8. 基数排序

​            \1. 排序规则：基数的选择和关键字的分解是根据关键字的类型来决定的，例如关键字是十进制数，则按个位、十位来分解

​             [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190929003541856-866512155.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190929003541856-866512155.png)

​           

 

**第十章：\**面向对象\****

  ***\*考点1：基础知识（★★★★★）\****

​     \1. 概念

​        \1. 对象：属性（数据）+方法（行为）+对象ID

​        \2. 类：对象的集合

​           \1. 实体类：现实世界中存在的实体，如人，物等

​           \2. 边界类(接口)：未用户提供一种与系统合作交互的方式，如显示屏、窗口、对话框、条形码、二维码等

​           \3. 控制类：控制活动流，充当协调者

​        \3. 接口：只有方法定义没有实现

 

​      \2. 三大特征

​        \1. 封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，提高安全性。

​        \2. 继承：提高代码复用性，是实现多态的前提。

​        \3. 多态：父类或接口定义的引用变量指向子类或具体实现类的实例对象，提高了代码的拓展性。

​        \4. 静态绑定：在编译时，把过程调用和响应调用所需要执行的代码加以结合

​        \5. 动态绑定：在运行时，把过程调用和响应调用所需要执行的代码加以结合

 

​      \3. 设计原则

​        \1. 单一职责原则SRP：类的功能要单一。

​        \2. 开放封闭原则OCP：扩展开放，修改关闭。

​        \3. 里式替换原则LSP：子类可以替换父类出现在父类能够出现的任何地方。

​        \4. 依赖倒置原则DIP：要依赖于抽象，而不是具体实现；针对接口编程，不要针对实现编程

​        \5. 接口分离原则ISP：使用多个专门的接口比使用单一的总接口要好

​         \6. 组合重用原则：要尽量使用组合，而不是继承关系达到重用目的

​        \7. 迪米特原则（最少知识法则）：一个对象应当对其他对象有尽可能少的了解

 

​      \4. 面向对象开发过程    

​        \1. 面向对象分析：获得对应问题的解决，抽取和整理用户需求并建立问题域精确模型

​           \1. 认定对象：按自然存在的实体确立对象。一般“名词”作为对象

​           \2. 组织对象：分析对象间的关系，将相关对象抽象成类，利用类的继承性建立具有继承性的层次的类结构

​           \3. 描述对象间的相互作用：描述对象在应用系统中的关系。

​        \2. 面向对象设计：采用协作的对象、对象的属性和方法解决软件问题的方案

​        \3. 面向对象实现：采用面向对象程序设计语言实现系统

​        \4. 面向对象测试：根据规范说明来验证系统设计的正确性

 

  ***\*考点2：UML（★★★★★）\****

​     \1. UML图分类

​          [![UMl](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923010145624-1466255381.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923010145624-1466255381.png)

 

​      \2. 用例图：描述系统和外部的交互关系。小人表示参与者，圆圈表示用例，实线空箭头表示泛化关系，虚线普通箭头<<extend>>表示扩展关系，虚线普通箭头<<include>>表示包含关系

​         [![用例图](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923010251588-1796811583.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923010251588-1796811583.png)

​     

​      \3. 类图：描述类、接口及协作之间的关系，用于系统的静态实现视图建模。箭头上可表示关系和角色，方框表示实体

​         \1. 依赖：一个类A使用到了另一个类B(作为类A的方法的参数)

​        \2. 关联：类B作为成员变量形成存在于类A中

​        \3. 聚合：整体与部分生命周期不同

​        \4. 组合：整体与部分生命周期相同

​        \5. 泛化：一个类与它的一个或多个细化类之间的关系

 

​         [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923010554465-1787840473.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923010554465-1787840473.png)

 

​      \4. 序列图：对象间消息的传递按时间顺序。对象名标有下划线，生命线为虚线，控制焦点用薄矩形表示，消息为箭头

​        \1. 同步消息：进行阻止调用，调用着终止执行，使用实心三角实线表示

​        \2. 异步消息：调用着发出消息后继续执行，不引起调用着阻塞，使用普通箭头实线表示

​         \3. 返回消息：使用普通箭头虚线表示    

​         

​         [![顺序图](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923105333866-2043545157.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923105333866-2043545157.png)

 

​      \5. 活动图：用于系统的动态视图建模，通常在建模用例图之后，对复杂用例进行进一步细化。黑色粗线条的数量表示能运行的最大线程数，在此区间的活动可以同时进行

​         [![活动图](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923120213783-1365470583.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923120213783-1365470583.png)

 

​      \6. 状态图：描述对象、子系统、系统的生命周期。圆圈代表状态，箭头表示监护条件

​         [![img](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923120253290-118822928.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923120253290-118822928.png)

 

​      \7. 通信图：表示对象和对象之间的调用关系。“：”表示对象，前面是对象名，后面是类名

​        [![通信图](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923120311796-1723055210.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923120311796-1723055210.png)

 

​      \8. 组件图：描述组件之间的组织和依赖，用于系统的静态实现视图，与类图相关，通常把组件映射为一个或多个类、接口和协作

​         [![构件图](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923120345854-590097985.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923120345854-590097985.png)

 

​      \9. 部署图：软件的构件应该部署在哪个硬件的节点上，用于系统的静态实施视图

​        [![部署图](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923120417937-1826419708.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923120417937-1826419708.png)

 

  ***\*考点3：设计模式（★★★★★）\****

​     \1. 设计模式分类

​         [![设计模式分类](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923104830553-694376595.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923104830553-694376595.png)

 

​      \2. 创建型模式

​         [![创建型模式](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923104845983-1861690053.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923104845983-1861690053.png)

 

​      \3. 结构型模式

​         [![结构型模式](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923104906150-380622076.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923104906150-380622076.png)

 

​      \4. 行为型模式

​         [![行为型模式](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923104926002-524291729.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923104926002-524291729.png)

​         [![行为型模式](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923104940522-2052224476.png)](https://img2018.cnblogs.com/blog/1610676/201909/1610676-20190923104940522-2052224476.png)