---

categories: 软件设计师
layout:     post
title:      "第三章 数据结构（上）"
date:       2021-03-14 10:37:54
author:     "Balbo"
header-img: "img/post-bg-2019.jpg"
catalog: true
tags:
    - 软件设计师

---

# 3.1 线性结构

## 3.1.1 线性表

1. 线性表的定义

   一个线性表是 n(n$\geq$0) 个元素的有限序列，通常表示为 $(a_1,a_2,\cdots,a_n)$。非空线性表的特点

   1. 存在唯一的一个称作 “第一个” 的元素。
   2. 存在唯一的一个称作 “最后一个” 的元素。
   3. 除第一个元素外，序列中的每个元素均只有一个直接前驱。
   4. 出最后一个元素外，序列中的每个元素均有一个直接后驱。

2. 线性表的存储结构

   线性表的存储结构分为顺序存储和链式存储

   1. 线性表的顺序存储

      线性表的顺序存储是指用一组地址连续的存储单元一次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在屋里位置上也相邻。

      在顺序存储结构中，第 i 个元素的 $a_i$ 的存储位置为 $LOC(a_i)=LOC(a_1)+(i-1)*L$，其中，L 是表中每个数据原民俗所占空间的字节数。

      优点：可以随机存取表中的元素

      缺点：插入和删除操作需要移动元素

      因此

      1. 插入一个新元素需要移动的元素个数期望值 $E_{insert}$ 为

          $E_{insert}=\sum_{i=1}^{n+1}P_i*(n-i+1)=\frac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)=\frac n2$

         其中，$P_i$ 表示在表中的位置 i 插入新元素的概率。

      2. 删除元素时时需要移动的元素个数期望值 $E_delete$ 为

         $E_{delete}=\sum_{i=1}^{n}q_i*(n-i)=\frac 1n\sum_{i=1}^{n}(n-i)=\frac {n-1}{2}$

         其中，$q_i$ 表示删除第 i 个元素的概率

   2. 线性表的链式存储

      线性表的链式存储是用通过指针链接起来的结点来存储数据元素。

      存储各数据元素的结点的地址并不要求是连续的，因此存储数据元素的同时必须存储元素之间的逻辑关系。另外，结点空间只有在需要的时候菜申请，无须事先分配。

      结点之间通过指针域构成一个链表，若结点中只有一个指针域，则称线性链表/单链表

      设线性表中的元素是整型，则单链表结点类型的定义为

      ```c
      typedet struct node{
      		int data;            /*结点的数据域*/
      		struct node *next;   /*结点的指针域*/
      }NODE, *LinkList;
      ```

      在链式存储结构下进行出啊如和删除，其实都是对相关指针的修改。在单链表中，若在 p 所指结点后插入新元素结点（s 所指结点，已经生成），其基本步骤为：

      1. $s\to next=p\to next;$
      2. $p\to next=s;$

      即先将 p 所指结点的后继结点指针赋给 s 所指结点的指针域，然后将 p 所指结点的指针域修改为向 s 所指结点。

      同理，在单链表中删除 p 所指结点的后继结点，其基本步骤为：

      1. $q=p\to next$
      2. $p\to next=p\to next\to next$
      3. $free(q)$

      即先令临时指针 q 指向待删除的结点，然后修改 p 所指结点的指针域为指向 p 所指结点的后继的后继结点，从而将元素 b 所在的结点从链表中删除，最后释放 q 所指结点的空间。

      在单链表上查找、插入和删除运算的实现过程

      1. 查找运算

         ```c
         LinkList Find_List(LinkList L,int k) /*L为带头结点单链表的头指针*/
         /*在表中查找第k个元素，若找到。返回改元素结点的指针；否则。返回空指针 NULL*/
         {	LinkList p;	int i;
         	i = 1;p = L->next;			/*初始时，令p指向第一个元素结点，i为计数器*/
          	while(p && i<k) {			/*顺时针链向后查找，直到p指向第k个元素结点或p为空指针*/
                 p = p->next; i++;
             }
             if(p && i == k) return p;	/*存在第k个元素且指针p指向改元素结点*/
             return NULL;				/*第k个元素不存在，返回空指针*/
         } /*Find_List*/
         ```

         

      2. 插入运算

         ```c
         LinkList Insert_List(LinkList L,int k,int newElem) /*L为带头结点单链表的头指针*/
         /*该元素 newElem 插入表中的第k个元素之前，若成功则返回0，否则返回-1*/
         /*该插入操作等同于将元素 newElem 插入在第k-1个元素之后*/
         {	LinkList p,s;						/*p、s为临时指针*/
         	if(k == 1) p = L;					/*元素 newElem 要插入到第1个元素之前*/
          	else p = Find_List(L,k-1);			/*查找表中的第k-1个元素并令p指向该元素结点*/
          	if(!p) return -1;					/*表中不存在第k-1个元素，不满足运算要求*/
          	s = (NODE*)malloc(sizeof(NODE));	/*创建新元素的结点空间*/
          	if(!s) return -1;
          	s->data = newElem;
          	s->next = p->next;  p->next = s;	/*将元素 newElem 插入第k-1个元素之后*/
          	return 0;
         	} /*Insert_List*/
         ```

         

      3. 删除运算

         ```c
         LinkList Delete_List(LinkList L,int k) /*L为带头结点单链表的头指针*/
         /*删除表中的第k个元素结点，若成功则返回0，否则返回-1*/
         /*删除第k个元素相当于令第k-1个元素结点的指针域指向第k+1个元素所在结点*/
         {	LinkList p,q;					/*p、q为临时指针*/
          	if(k == 1) p = L;				/*删除的是第一个元素结点*/
          	else p = Find_List(L,k-1);		/*查找表中的第k-1个元素并令p指向该元素结点*/
          	if(!p||!p->next) return -1;		/*表中不存在第k个元素*/
         	q = p-next;						/*令q指向第k个元素结点*/
          	p->next = q->next;  free(q);	/*删除结点*/
          	return 0;
         } /*Delete_List*/
         ```

      优点：具有插入和删除操作不需要移动元素

      缺点：不能对数据元素惊醒随机访问

根据结点中指针域的设置方式，还有其他几种链表结构。

+ 双向链表。每个结点包含两个指针，分别指出当前元素的直接前驱和直接后驱。其特点是可以从表中任意的结点出发，从两个方向上遍历链表。
+ 循环链表。在单向链表（或双向链表）的基础上令表尾结点的指针指向链表的第一个结点，构成循环链表。其特点是可以从表中任意结点开始遍历整个链表。
+ 静态链表。借助数组来描述线性表的链式存储结构，用数组元素的下标表示元素所在结点的指针。

若双向链表中结点的 front 和 next 指针域分别指示当前结点的直接前驱和直接后驱，则在双向链表中插入结点\*s时指针的变化情况：

1. $s\to front=p\to front;$
2. $p\to front\to next=s;$
3. $s\to next=p;$
4. $p\to front=s;$

在双向链表中删除结点时指针的变化情况：

1. $p\to front\to next=p\to next;$
2. $p\to next\to front=p\to front;free(p);$

## 3.1.2 栈和队列

1. 栈

   1. 栈的定义及基本运算

      1. 栈是只能通过访问它的一端来实现数据存储和检索的一种线性数据结构。换句话说，栈的修改是按先进后出的原则进行的。
      2. 栈的运算
         1. 初始化栈 InitStack(S)：创建一个空栈 S
         2. 判栈空 isEmpty(S)：当栈 S 为空时返回 ”真“，否则 ”假“
         3. 入栈 Push(S,x)：将元素 x 加入栈顶，并更新栈顶指针
         4. 出栈 PoP(S)：将栈顶元素从栈中删除，并更新栈顶指针。若需要得到栈顶元素的值，可将 PoP(S) 定义为一个返回栈顶元素值的函数。
         5. 读栈顶元素 Top(S)：返回栈顶元素的值，但不修改栈顶指针。

   2. 栈的存储结构

      1. 顺序存储。栈的顺序存储是指一组地址连续的存储单元一次存储自栈顶带栈底的数据元素，同时附设指针 top 指示栈顶元素的位置。采用顺序存储结构的栈也称为顺序栈。在这种存储方式下，需要预先定义（或申请）栈的存储空间，也就是说，栈空间的容量的有限的。因此，在顺序栈中，当一个元素入栈时，需要判断是否栈满（栈空间中没有空闲单元），若栈满，则元素不能入栈。

      1. 栈的链式存储。用链表作为存储结构的栈也称为链栈。由于栈中元素的插入和删除仅在栈顶一端进行，因此不必另外设置头指针，链表的头指针就是栈顶指针。
      2. 栈的应用。栈的典型应用包括表达式求值、口号匹配等，在计算机语言的实现以及将递归过程转变为非递归过程的处理中，栈由重要作用。

2. 队列

   1. 队列的定义及基本运算

      1. 队列的定义。队列是一种先进先出(First In First Out,FIFO)的线性表，它只允许在表的一端插入元素，而在表的另一端删除元素。在队列中，允许插入元素的一端称为队尾(Rear)，允许删除元素的一端称为对头(Front)。
      2. 队列的基本运算
         1. 初始化队列 InitQueue(Q)：创建一个空队列Q
         2. 判队空 isEmpty(Q)：当队列为空时返回 ”真“，否则 ”假“
         3. 入队 EnQueue(Q,x)：将元素 x 加入到队列 Q 的队尾，并更新队尾指针
         4. 出队 DelQueue(Q)：将队头元素从队列 Q 中删除，并更新队头指针
         5. 读栈顶元素 FrontQue(Q)：返回队头元素的值，但不更新队头指针。

   2. 队列的存储结构

      1. 队列的顺序存储。

         设顺序队列 Q 的容量为 6，其队头指针为 front，队尾指针为 rear，头、尾指针和队列元素之间的关系

         ![（a）状态转换图](img/software/queue.png)

         在顺序队列中，为了降低运算的复杂度，元素入队时只修改队尾指针，元素出队时只修改队头指针。由于顺序队列的存储空间容量时提前设定的，所以队尾指针会由一个上限值，当队尾指针达到该上限时，就不能只通过修改队尾指针来实现新元素的入队操作了。若将顺序队列假想成一个环状结构，则可维持入队、出队操作运算的简单性，称为循环队列。

         设循环队列 Q 的容量为 MAXSIZE，初始时队列为空，且 Q.rear 和 Q.front 都等于 0。

         1. 元素入队时，修改队尾指针 Q.rear = (Q.rear+1)%MAXSIZE。
         2. 元素出队时，修改队头指针 Q.front = (Q.front+1)%MAXSIZE。
         3. 根据队列操作的定义，当出队操作导致队列变为空时，则由 Q.rear==Q.front；当入队操作导致队列满，则 Q.rear==Q.front。
         4. 在队列空和队列满的情况下，循环队列的队头、队尾指向的位置时相同的，此时仅仅根据 Q.rear 和 Q.front 之间关系无法断定队列的状态。为了区别队空和队满的情况，有两种处理方式可采用：
            1. 设置一个标志，以区别头、尾指针的值相同队列时空还是满
            2. 牺牲一个存储单元，约定以“队列的尾指针所指位置的下一个位置是队头指针时”表示队列满

         ```c
         #define MAXQSIZE 100
         typedef struct {
         	int *base;		/*循环队列的存储空间，假设队列中存放的时整型数*/
         	int front;		/*指示队头，称为队头指针*/
         	ont rear;		/*指示队尾，称为队尾指针*/
         }SqQueue;
         ```

         ```c
         int InitQueue(SqQueue *Q)
         /*常见容量为 MAXQSIZE 的空队列，若成功返回0，否则-1*/
         {	Q->base = (int*)malloc(MAXQSIZE*sizeof(int));
         	if(!Q->base) return -1;
         	Q->front = 0; Q->rear = 0; return 0;
         }/*InitQueue*/
         ```

         ```c
         int EnQueue(SqQueue *Q,int e) /*元素e入队，若成功返回0，否则-1*/
         {	if((Q->rear+1)%MAXQSIZE == Q->front) return -1;
         	Q->base[Q->rear] = e;
         	Q->rear = (Q->rear + 1)%MAXQSIZE;
         	return 0;
         }/*EnQueue*/
         ```

         ```c
         int DelQueue(SqQueue *Q,int *e)
         /*若队列不空，则删除队头元素，有参数e带回其值并返回0，否则返回-1*/
         {	if(Q->rear == Q->front) return -1;
         	*e = Q->base[Q->front];
         	Q->front = (Q->front + 10)%MAXQSIZE;
         	return 0;
         }/*DelQueue*/
         ```

         

      2. 队列的链式存储。

         队列的链式存储也称为链队列。这里为了便于操作，给链队列添加一个头结点，并令头指针指向头结点。因此，队列为空的判定条件时头指针和为指针的值相同，且均指向头结点。

      3. 队列的应用。

         队列结构仓用于处理需要排队的场合，例如操作系统中处理打印任务的打印队列、离散事件的计算机模拟等。

## 3.1.3 串

串（字符串）时一种特殊的线性表，其数据元素为字符。计算机中非数值问题处理的对象经常时字符串数据。

1. 串的定义及基本运算

   1. 串的定义

      串是仅由字符构成的有限序列，是一种线性表。一般记为 $S='a_1a_2\cdots a_n'$，其中，S 是串名，单引号括起来的字符序列是串值。

   2. 串的几个基本概念

      + 空串：长度为零的串称为空串，空串不包含任何字符
      + 空格串：由一个或多个空格组成的串。
      + 子串：由串中任意长度的连续字符构成的序列称为子串。含有子串的串称为主串。子串在主串中的位置是指子串首次出现时，该子串的第一个字符在主串中的位置。空串是任意串的子串。
      + 串相等：指两个串长度相等且对应序号的字符也相同
      + 串比较：两个串比较大小时以字符的 ASCII 码值（或其他字符编码集合）作为依据。实质上，比较操作从两个串的第一个字符开始进行，字符的码值大者所在的串为大；若其中一个串线结束，则以串长较大者为大。

   3. 串的基本操作

      1. 赋值操作 StrAssign(s,t)：将串 s 的值赋给串 t。
      2. 连接操作 Concat(s,t)：将串 t 接续在串 s 的尾部，形成一个新串。
      3. 求串长 StrLrngth(s)： 返回串 s 的长度。
      4. 串比较 StrCompare(s,t)：比较两个串的大小。
      5. 求子串 SubString(s.start,len)：返回串 s 中从 start 开始的、长度为 len 的字符序列。

2. 串的存储结构

   串可以进行顺序存储或链式存储

   1. 串的顺序存储结构。串的顺序存储结构是值用一组地址连续的存储单元来存储串值的字符序列。
   2. 串的链式存储结构。当用链表存储串中的字符时，每个结点中可以存储一个字符，也可以存储多个字符，此时要考虑存储密度问题。

3. 串的模式匹配

   子串的定位操作通常称为串的模式匹配，它是各种串处理系统中最只要的运算之一。子串也称为模式串。

   1. 朴素的模式匹配算法

      该算法也称为布鲁特——福斯算法，其基本思想是从主串的第一个字符起与模式串的第一个字符比较，若相等，则继续逐一对字符进行后续的比较，否则从主串第二个字符起与模式串的第一个字符重新比较，直到模式串中每个字符一次和主串中一个连续的字符序列相等时为止，此时称为匹配成功。如果不能在主串中找到与模式串相同的子串，则匹配失败。

      ```c
      /*以字符数组存储字符串。实现朴素的模式匹配算法*/
      int Index(char S[],char T[],int pos)
      /*查找并返回模式串T在主串S中从pos开始的位置（下标），若T不是S的子串，则返回-1*/
      /*模式串T和主串S第一个字符的小标为0*/
      {	int i,j,slen,tlen;
      	i = pos; j = 0;						/*i、j分别用于指出主串字符和模式串字符的位置*/
      	slen = strlen(S); tlen = strlen(T);	  /*计算主串和模式串的长度*/
      	while(i<slen && j<tlen) {
      		if(S[i] == T[i]) {i++; j++;}
      		else{
      			i = i- j + 1;				/*主串字符的位置指针回退*/
      			j = 0;
      		}
      	}/*while*/
      	if(j >= tlen) return i - tlrn;
      	return -1;
      }/*Index*/
      ```

      

   2. 改进的模式匹配算法

      改进的模式匹配算法又称为 KMP 算法，其改进之处在于：每当匹配过程中出现相比较的字符不相等时，不需要回退主串的字符位置指针，而是利用已经得到的“部分匹配”结果将模式串向右“滑动”尽可能远的地方，在继续进行比较。

      <font color="red">设模式串为 “$p_0\cdots p_{m-1}$"，KMP 匹配算法的思想时：当模式串中的字符 $p_j$ 与主串中相应的字符 $S_i$ 不相等时，因其前 j 个字符("$p_0\cdots p_{j-1}$")已经获得了成功的匹配，所以若模式串中的 "$p_0\cdots p_{k-1}$" 与 "$p_{j-k}\cdots p_{j-1}$" 相同，这时可令 $p_k$ 与 $S_i$ 进行比较，从而使 i 无需回退。</font>

      ```c
      void Get_next(char *p,int next[])		/*求模式串p的next函数值并存入数组next*/
      {	int i,j,slen;
      	slen = strlen(p); i = 0;
      	next[0] = -1; j = -1;
      	while(i < slen) {
      		if(j == -1 || p[i] == p[j]) {++i;++j;next[i] = j;}
      		else j = next[i];
      	}/*while*/
      }/*Get_next*/
      ```

      ```c
      int Index_KMP(char *s,char *p,int pos,int next[])
      /*利用模式串p的next函数，求p在主串s中从第pos个字符开始的位置*/
      /*若匹配成功。返回模式串在主串中的位置（下标），否则返回-1*/
      {	int i,j,slen,plen;
      	i = pos-1;
      	j = -1;
      	slen = strlen(s); plen = strlen(p);
      	while(i < slen && s[i] == p[j]) {
      		if(j == -1 || s[i] == p[j]) {++i; ++j;}
      		else j = next[j];
      	}/*while*/
      	if(j >= plen) return i - plen;
      	else return -1;
      }/*Index_KMP*/
      ```

      

# 3.2 数组、矩阵和广义表

## 3.2.1 数组

1. 数组的定义及基本运算

   1. 数组的定义

      数组使定长线性表在维数上的扩展，即线性表中的元素又是一个线性表。n维数组是一种”同构“的数据结构，其每个数组元素类型相同、结构一致。

      数据结构的特点：

      1. 数据元素数目固定，一旦定义了一个数组结构，就不再有元素个数的增减变化。
      2. 数据元素具有相同的类型。
      3. 数据元素的下标关系具有上下界的约束且下标有序。

   2. 数组的两个基本运算

      1. 给定一组下标，存取相应的数据元素。
      2. 给定一组下标，修改相应的数据元素中某个数据项的值。

2. 数组的顺序存储

   数组一般不做插入和删除运算，一旦定义了数组，则结构中的数据元素个数和元素之间的关系就不再发生变动，因此数组适合于采用顺序存储结构。

   二维数组的存储结构可分为以行为主序很大以列为主序的两种方法

   设每个数据元素占用L个单元，m、n为数组的航叔和列数，$Loc（a_{11})$ 表示元素 $a_{11}$ 的地址，那么以行为主序优先存储的地址计算公式为：

   $$Loc(a_{ij})=Loc(a_{11})+((i-1)*n+(j-1))*L$$

   同理，以列为主序优先存储的地址计算公式为：

   $$Loc(a_{ij})=Loc(a_{11})+((j-1)*m+(i-1))*L$$

## 3.2.2 矩阵

矩阵式很多科学与过程计算领域研究的数学对象。在数据结构中，主要讨论如何在节省存储空间的情况下使矩阵的各种运算能搞笑地进行。

1. 特殊矩阵

   若矩阵中元素（或非0元素）的分布有一定的规律，则称为特殊矩阵。常见的特殊矩阵有对称矩阵、三角矩阵和对焦矩阵等。对于特殊矩阵，由于其非0元素的发布有一定的规律，所以可将其压缩存储在一维数组中,并建立起每个非0元素在矩阵中的位置与其在一维数组中的位置之间的对应关系

   若矩阵 $a_{n*n}$ 中的元素特点为 $a_{ij}=a_{ji}(1\leq i,j\leq n)$，则称为 n 阶对称矩阵

   若对称矩阵中的每一对元素仅占用一个存储单元，那么可将 $n^2$ 个元素压缩存储到能存放 $n(n+1)/2$ 个元素的存储空间中。不失一般性，以下为主序存储下三角（包括对角线）中的元素。假设以一维数组 $B[n(n+1)/2]$ 作为 n 阶堆成矩阵 A 中元素的存储空间，则 $B[k](1\leq k<n(n+1)/2)$ 与矩阵元素 $a_{ij}(a_{ji})$ 之间存在着一一对应的关系：

   $$ k= \begin{cases} \frac{i(i-1)}{2}+j, & 当 i\geq j \\ \frac{j(j-1)}{2}+i, & 当i<j \end{cases} $$ 

   对角矩阵是指矩阵中的非0元素都集中在主对焦线为中心的带状区域中，即处理主对角线上和直接在对角线上、下方若干条对角线上的元素外，其余的矩阵元素都为0。一个 n 阶的三对角矩阵如图

   $$A_{n*n}=\begin{bmatrix} a_{1,1}&a_{1,2} \\ a_{2,1}&a_{2,2}&a_{1,3}&&&0 \\ &a_{3,2}&a_{3,3}&a_{3,4} \\ &&&\cdots&\cdots&\cdots& \\ &&&a_{i,i-1}&a_{i,i}&a_{i,i+1} \\ &&&&\cdots&\cdots&\cdots \\ &&&&&a_{n,n-1}&a_{n,n} \\ \end{bmatrix} $$

   若以行为主序将 n 阶三对角矩阵 $A_{n*n}$ 的非0元素 $a_{ij}$ 存储在一维数组 $B[k](1\leq k\leq 3*n-2)$ 中，则元素位置之间的对应关系为$k=3*(i-1)-1+j-i+1+1=2i+j-2(1\leq i,j\leq n)$

2. 稀疏矩阵

   在一个矩阵中，若非0元素的个数远远少于0元素的个数，且非0元素的发布没有规律，则称之为稀疏矩阵。对于稀疏矩阵，存储非0元素时必须同时存储其位置，所以三元组 $(i,j,a_{ij})$ 可唯一确定矩阵 A 中的一个元素。由此，一个稀疏矩阵可由表示非0元素的三元组机器行、列数唯一确定。如图，其三元组表为 $((1,2,12),(1.3,9),(3,1,-3),(3,6,14),(4,3,24),(5,2,18),(6,1,15),(6,4,-1))$。

   $ M_{6*7}=\begin{bmatrix} 0&12&9&0&0&0&0 \\ 0&0&0&0&0&0&0& \\ -3&0&0&0&0&14&0 \\ 0&0&24&0&0&0&0& \\ 0&18&0&0&0&0&0 \\ 15&0&0&-7&0&0&0  \end{bmatrix} $ 

## 3.2.3 广义表

广义表时线性表的推广，是由0个或多个单元素或子表组成的有限序列。

广义表与线性表的区别在于：线性表的元素都是结构上不可分的单元素，而广义表的元素既可以是单元素，也可以是由结构的表

一般记为 $LS=(a_1,a_2,\cdots,a_n)$

其中，$a_i(1\leq i\leq n)$既可以是单个元素，又可以是广义表，分别称为原子和子表。

广义表的长度是指广义表中元素的个数。广义表的深度是指广义表展开后所含的看好的最大层数。

1. 广义表的基本操作

   1. 取表头 head(LS)。非空广义表 LS 的第一个元素称为表头，它可以是一个单元素，也可以是一个子表
   2. 取表尾 tail(LS)。在非广义表中，除表头元素之外，由其余元素所构成的表称为标表尾。非空广义表的表尾必定是一个表。

2. 广义表的特点

   1. 广义表可以是多层次的结构，因为广义表的元素可以是子表，而子表的元素还可以是子表
   2. 广义表中的元素可以是已经定义的广义表的名字，所以一个广义表可被其他广义表所共享
   3. 广义表可以是一个递归的表，即广义表中的元素也可以是本广义表的名字

3. 广义表的存储结构

   由于广义表中的元素本身由可以具有结构，它是一种带有层次的非线性结构，因此难以用顺序存储结构表示，通常采用链式存储结构。由上面的讨论可知，若广义表不空，则可分解为表头和表尾两部分。反之，一对确定的表头和表尾可唯一确定一个广义表。

# 3.3 树

## 3.3.1 树与二叉树的定义

1. 树的定义
2. 树的基本概念
3. 二叉树的定义

## 3.3.2 二叉树的性质与存储结构

1. 二叉树的性质
2. 二叉树的存储结构

## 3.3.3 二叉树的遍历

## 3.3.4 线索二叉树

1. 线索二叉树的定义
2. 建立线索二叉树
3. 访问线索二叉树

## 3.3.5 最优二叉树

1. 最优二叉树
2. 哈夫曼编码

## 3.3.6 树和森林

1. 树的存储结构
2. 树和森林的遍历
3. 树、森林和二叉树之间的相互转换
