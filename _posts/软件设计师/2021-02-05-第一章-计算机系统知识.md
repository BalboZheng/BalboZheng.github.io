---

categories: 软件设计师
layout:     post
title:      "第一章 计算机系统知识"
date:       2021-02-06 12:30:11
author:     "Balbo"
header-img: "img/post-bg-2019.jpg"
catalog: true
tags:
    - 软件设计师

---

# 1.1 计算机系统基础知识

## 1.1.2 中央处理单元

### CPU的功能

   1. 程序控制。CPU通过执行指令来控制存的执行顺序，这是CPU的重要功能。

   2. 操作控制。一条指令功能的实现需要若干操作信号配合来完成，CPU产生每条指令的操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。

   3. 时间控制。CPU对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。

   4. 数据处理。CPU通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理的结果被人们所利用。所以，对数据的加工处理也是CPU最根本的任务。

      > CPU还需要对心痛内部和外部的中断做出响应，进行相应的处理。

### CPU的组成

   1. 运算器
      1. 运算器有两个功能：

          1. 执行所有的算术运算。（*例如加、减、乘、除等基本运算及附加运算*）

          2. 执行所有的逻辑运算并进行逻辑测试。（*例如与、或、非、零值测试或两个值的比较等*）

      2. 运算符中各组成部件的功能：

      3. 算术逻辑单元（**ALU**）。ALU 是运算器的重要组成部件，负责处理数据，实现对数据的算术运算和逻辑运算。

      4. 累加寄存器（**AC**）。AC 通常简称为累加器，他是一个通用寄存器，器功能是当运算器的算术逻辑单元执行算术或逻辑运算是，为 ALU 提供一个工作区。

      5. 数据缓冲寄存器（**DR**）。在对内存储器进行读/写操作是，用 DR 暂时放由内存储器读/写的一条指令或一条数据字，记那个不同时间段内读/写的数据隔离开来。

      6. 状态条件寄存器（**PSW**）。PSW 保存由算术指令和逻辑指令运行或测试的结果建立的各种条件码内容，主要分为状态标志和控制标志，例如运算结果进位标志（**C**）、运算结果移除标志（**V**）、运算结果位 0 标志（**Z**）、运算结果为负标志（**N**）、中断标志（**I**）、方向标志（**D**）和单步标志等。这些标志通常分别由 1 位触发器保存，保存了当前指令执行完成之后的状态。

   2. 控制器
      运算器只能完成运算，而控制器用于控制整个 CPU 的工作，他决定了计算机运行过程的自动化。
      指令控制逻辑要完成取指令、分析指令和执行指令的操作，其过程分为取指令、指令译码、按指令操作码执行、形成下一条指令地址等步骤。

      1. 指令寄存器（**IR**）。当 CPU 执行一条指令时，先把他从内存储器取到缓冲寄存器中，在送入 IR 暂存，指令译码器更具 IR 的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能。
      2. 程序计数器（**PC**）。PC  具有寄存信息和计数两种功能，又称为指令计数器。
      3. 地址寄存器（**AR**）。AR 保存当前 CPU 所访问的内存单元的地址。
      4. 指令译码器（**ID**）。指令包含操作码和地址码两部分，为了能执行任何给定的指令，必须对操作码进行分析，一遍识别所完成的操作。
      > 时序控制逻辑：为每条指令按时间顺序提供应有的控制信号。
      >
> 总线逻辑：为多个功能部件服务的信息通路的控制电路。
      
   3. 寄存器组
      寄存器组可风味专用寄存器和通用寄存器。运算器和控制器中的寄存器是专用寄存器。

### 多核 CPU

   ​	核心又称为内核，是 CPU 最重要的组成部分。CPU 中心那块隆起的芯片就是核心，是由单晶硅以一定的生产工艺制造出老的，CPU 所有的计算、接收/存储命令、处理数据都由核心执行。

## 1.1.3 数据表示

​	各种数值在计算机中表示的形式称为机器数。机器数有无符号数和带符号数之分。无符号数表示整数，在机器数中没有符号位。

为了便于运算，带符号的机器数可采用原码、反码和补码等不同的编码方法，机器数的这些编码方法成为码制。

1. 原码、反码、补码和移码

   1. 原码表示法。数值 *X* 的原码计为 [*X*]<sub>原</sub>,  如果及其字长位 n （即采用 n 个二进制位表示数据），则原码的定义如下：
      
      $ m = gamma m_0 = frac{m_0}{sqrt{1-v^2/c^2}} $
      
      
   $$
      若 X 是纯整数，则[X]_原=\begin{cases} X，0\leq X \leq 2^{n-1}-1\\ 2^{n-1}+|X|， -(2^{n-1}-1)\leq X \leq 0 \end{cases}  \\
      若 X 是纯小数，则[X]_原=\begin{cases} X，0\leq X < 1\\ 2^0+|X|， -1 < X \leq 0 \end{cases}
      $$
      
      
      
      

      ```word
      【例1.1】 若机器字长 n 等于 8，分别给出+1，-1，+127，-127，+45，-45，+0.5，-0.5的原码表示。
      	【+1】 = 0 0000001            【+1】 = 1 0000001 
      	【+127】 = 0 1111111          【+127】 = 1 1111111 
      	【+45】 = 0 0101101           【+45】 = 1 0101101 
      	【+0.5】 = 0 ◇1000000         【+0.5】 = 1 ◇1000000 
      ```
      
   2. 反码表示法。数值 *X* 的原码计为 [*X*]<sub>反</sub>,  如果及其字长位 n ，则原码的定义如下：
      $$
      若 X 是纯整数，则[X]_反=\begin{cases} X，0\leq X \leq 2^{n-1}-1\\ 2^{n-1}+X， -(2^{n-1}-1)\leq X \leq 0 \end{cases}  \\
      若 X 是纯小数，则[X]_反=\begin{cases} X，0\leq X < 1\\ 2-2^{-(n-1)}+X， -1 < X \leq 0 \end{cases}
      $$

      ```word
      【例1.1】 若机器字长 n 等于 8，分别给出+1，-1，+127，-127，+45，-45，+0.5，-0.5的反码表示。
      	【+1】 = 0 0000001            【+1】 = 1 1111110 
      	【+127】 = 0 1111111          【+127】 = 1 0000000 
      	【+45】 = 0 0101101           【+45】 = 1 1010010 
      	【+0.5】 = 0 ◇1000000         【+0.5】 = 1 ◇0111111 
      ```

   3. 补码表示法。数值 *X* 的原码计为 [*X*]<sub>补</sub>,  如果及其字长位 n ，则原码的定义如下：
      $$
      若 X 是纯整数，则[X]_补=\begin{cases} X，0\leq X \leq 2^{n-1}-1\\ 2^{n}+X， -2^{n-1}\leq X \leq 0 \end{cases}  \\
      若 X 是纯小数，则[X]_补=\begin{cases} X，0\leq X < 1\\ 2+X， -1 \leq X < 0 \end{cases}
      $$

      ```word
      【例1.1】 若机器字长 n 等于 8，分别给出+1，-1，+127，-127，+45，-45，+0.5，-0.5的补码表示。
      	【+1】 = 0 0000001            【+1】 = 1 1111111 
      	【+127】 = 0 1111111          【+127】 = 1 0000001 
      	【+45】 = 0 0101101           【+45】 = 1 1010011 
      	【+0.5】 = 0 ◇1000000         【+0.5】 = 1 ◇1000000 
      ```

   4. 移码表示法。移码表示法是在数 X 上增加一个偏移量来定义的，常用与表示浮点数中的阶码。如果机器字长位 n，规定偏移量为
      $$
      2^{n-1}
      $$
      ，则原码的定义如下：
      $$
      若 X 是纯整数，则[X]_移=2^{n-1}+X， -(2^{n-1}-1)\leq X < 2^{n-1}   \\
      若 X 是纯小数，则[X]_移=1+X， -1 \leq X < 1
      $$

      ```word
      【例1.1】 若机器字长 n 等于 8，分别给出+1，-1，+127，-127，+45，-45，+0，-0的移码表示。
      	【+1】 = 1 0000001            【+1】 = 0 1111111 
      	【+127】 = 1 1111111          【+127】 = 0 0000001 
      	【+45】 = 1 0101101           【+45】 = 0 1010011 
      	【+0】 = 1 0000000            【+0】 = 1 0000000 
      ```

2. 定点数和浮点数

   1. 定点数。所谓定点数，就是小数点的位置固定不变的数。

      机器字长位 n 时各种码制表示的带符号数的范围

      | 码制 |                           定点整数                           |                           定点小数                           |
      | :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
      | 原码 | ![img](https://latex.codecogs.com/gif.latex?-%282%5E%7Bn-1%7D-1%29)~![img](https://latex.codecogs.com/gif.latex?&plus;%282%5E%7Bn-1%7D-1%29) | -![img](https://latex.codecogs.com/gif.latex?%281-2%5E%7B-%28n-1%29%7D%29)~+![img](https://latex.codecogs.com/gif.latex?%281-2%5E%7B-%28n-1%29%7D%29) |
      | 反码 | ![img](https://latex.codecogs.com/gif.latex?-%282%5E%7Bn-1%7D-1%29)~![img](https://latex.codecogs.com/gif.latex?&plus;%282%5E%7Bn-1%7D-1%29) | -![img](https://latex.codecogs.com/gif.latex?%281-2%5E%7B-%28n-1%29%7D%29)~+![img](https://latex.codecogs.com/gif.latex?%281-2%5E%7B-%28n-1%29%7D%29) |
      | 补码 | ![img](https://latex.codecogs.com/gif.latex?-2%5E%7Bn-1%7D)~![img](https://latex.codecogs.com/gif.latex?&plus;%282%5E%7Bn-1%7D-1%29) | -1~![img](https://latex.codecogs.com/gif.latex?&plus;%281-2%5E%7B-%28n-1%29%7D%29) |
      | 移码 | ![img](https://latex.codecogs.com/gif.latex?-2%5E%7Bn-1%7D)~![img](https://latex.codecogs.com/gif.latex?&plus;%282%5E%7Bn-1%7D-1%29) | -1~![img](https://latex.codecogs.com/gif.latex?&plus;%281-2%5E%7B-%28n-1%29%7D%29) |

      

   2. 浮点数

      1.  浮点数的表示：N=M*Re，M为尾数，R为基数，e为阶码

         1. 尾数用补码表示，阶码用移码表示
         2. 尾数的位数决定数的有效精度，位数越多精度越高
         3.  阶码的位数决定数的表示范围，位数越多范围越大

      2. 浮点数的运算

         1.  对阶，将阶码小的扩大，使两个数的阶码相同
         2.  求尾数和(差)
         3. 结果规格化并判断溢出
         
## 1.1.4 校验码

1. 奇偶校验码

   ​	奇偶校验（Parity Codes）是一种简单有效的校验方法。这种方法通过在编码中增加一位校验位来使编码中 1 的个数位奇数（奇校验）或者为偶数（偶校验），从而使码距变为 2。

   ​	常用的奇偶校验码有 3 种：水平奇偶校验码、垂直奇偶校验码和水平垂直校验码。

2. 海明码

   ​	海明码（Hamming Code）的构成方法是在数据位之间的特定位置上插入 k 个校验码，通过扩大码距老实现检错和纠错。

   ​	设数据位是 n 位，校验位是 k 位，则 n 和 k 必须满足以下关系：
   $$
   2^k-1 \geq n+k
   $$
   ​	海明码的编码规则如下。

   ​	设 k 个校验位位![img](https://latex.codecogs.com/gif.latex?P_%7Bk%7D)，![img](https://latex.codecogs.com/gif.latex?P_%7Bk-1%7D)，···，![img](https://latex.codecogs.com/gif.latex?P_%7B1%7D)， n 个数据位为 ![img](https://latex.codecogs.com/gif.latex?D_%7Bn-1%7D)，![img](https://latex.codecogs.com/gif.latex?D_%7Bn-2%7D)，···，![img](https://latex.codecogs.com/gif.latex?D_%7B0%7D)，对应的海明码为![img](https://latex.codecogs.com/gif.latex?H_%7Bn&plus;k%7D)，![img](https://latex.codecogs.com/gif.latex?H_%7Bn&plus;k-1%7D)，···，![img](https://latex.codecogs.com/gif.latex?H_%7B1%7D)，那么：

   1. ![img](https://latex.codecogs.com/gif.latex?P_i)在海明码的第 ![img](https://latex.codecogs.com/gif.latex?2%5E%7Bi-1%7D) 位置，即![img](https://latex.codecogs.com/gif.latex?H_j)=![img](https://latex.codecogs.com/gif.latex?P_i)，且j=![img](https://latex.codecogs.com/gif.latex?2%5E%7Bi-1%7D)，数据位则依序从低到高占据海明码中剩下的位置。

   2. 海明码中的任何意为都是由若干个校验位来校验的。其对应关系如下：被校验的海明位的下标等于所有参与校验该位的校验位的下标之和，而校验位由自身校验。

   ```
   【例1.6】 设数据为 01101001，试采用 4 个校验位求其偶校验方式的海明码。
   解：D_7D_6D_5D_4D_3D_2D_1D_0=01101001，根据公式
      P_1 = D_0 + D_1 + D_3 + D_4 + D_6 = 1 + 0 + 1 + 0 + 1 = 1
      P_2 = D_0 + D_2 + D_3 + D_5 + D_6 = 1 + 0 + 1 + 1 + 1 = 0
      P_3 = D_1 + D_2 + D_3 + D_7 = 0 + 0 + 1 + 1 = 1
      P_4 = D_4 + D_5 + D_6 + D_7 = 0 + 1 + 1 + 0 = 0
      求得的海明码位：
      H_12 H_11 H_10 H_9 H_8 H_7 H_6 H_5 H_4 H_3 H_2 H_1
      D_7  D_6  D_5  D_4 P_4 D_3 D_2 D_1 P_3 D_0 P_2 P_1
       0    1    1    0   0   1   0   0   1   1   0   1
   ```

   

3. 循环冗余校验码

   ​	循环冗余效验码（Cyclic Redundancy，CRC）利用生成多项式为 k 个数据位产生 r 个校验位来进行编码，其编码长度为 k+r。

# 1.2 计算机体系结构

## 1.2.1 计算机体系结构的发展

### 计算机体系结构分类

1. 从宏观上按处理机的数量进行分类，分为单处理系统、并行处理与多处理系统和分布式处理系统。

2. 从微观上按并行程度分类，有 <font color="red">Flynn 分类法</font>、冯泽云分类法、Handler分类法和Kuck分类法。

### 指令系统

1. CISC和RISC

   ​	CISC和RISC是指令集发展的两种途径

   1. CISC（<font color="red">Complex</font> Instruction Set Computer，复杂集计算机）的基本思想是进一步增强原有指令的功能，用更为复杂的新指令取代原先有软件子程序完成的功能，实现软件功能的硬化，导致及其的指令系统越来越庞大、复杂。

      + 弊端：

      + 指令集过分庞杂
      + 微程序技术是 CISC 的重要支柱，每条复杂指令都要通过执行一段解释性为程序才能完成，这就需要多个 CPU 周期，从而降低了机器的处理速度
      + 由于指令系统过分庞大，使高级语音编译程序选择目标指令的范围很大，并使编译程序本身冗长、复杂，从而难以优化编译使之生成真正高效的目标代码
      + CISC 强调完善的终端控制，势必导致动作繁多、设计复杂、研制周期长
      + CISC 给芯片设计带来很多困难，使芯片种类增多，出错几率增大，成本提高而成品率降低

   2. RISC（<font color="red">Reduced</font> Instruction Set Computer,精简指令集计算机）的基本思想是通过减少指令总数和简化指令功能降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的执行速度，采用硬布线控制逻辑优化编译程序。

      + 关键技术：
      + 重叠寄存器窗口技术。
      + 优化编译技术。
      + 超流水及超标量技术。
      + 硬布线逻辑与微程序相结合在微程序技术中。

   

### 指令的流水处理

1. 指令控制方式。指令控制方式有顺序方式、重叠方式和流水方式 3 种。

2. 流水线的种类。
   1. 从流水的级别上，可分为部件级、处理机级以及系统级的流水
   2. 从流水的功能上，可分为单功能流水线和多功能流水线
   3. 从流水的连接上，可分为静态流水线和动态流水线
   4. 从流水是否有反馈回路，可分为线性流水线和非线性流水线
   5. 从流水的流动顺序上，可分为同步流水线和异步流水线
   6. 从流水线的数据表示上，可分为标量流水线和向量流水线

3. 吞吐率和流水建立时间

   ​	吞吐率是指党委时间内流水线处理机流出的结果数。对指令而言，就是单位时间内执行的指令数。如果流水线的子过程所用时间不一样，则吞吐率 p 应为最长子过程的倒数，即：
   $$
   p=1/max｛\Delta t_1,\Delta t_2,...,\Delta t_m｝
   $$
   ​	流水线开始工作，需经过一定时间才能达到最大吞吐率，这就是建立时间。若 m 个子过程所用时间一样，均为![img](https://latex.codecogs.com/gif.latex?%5CDelta%20t_0)，则建立时间
   $$
   T=m\Delta t_0
   $$
   

## 1.2.2 存储系统

1. 存储器的分类
   1. 按存储器所处的位置可分为内存和外存
   2. 按构成存储器的材料可分为磁存储器、半导体存储器和光存储器
   3. 按存储器的工作方式可分为读/写存储器和只读存储器
   4. 按访问方式可分为按地址访问的存储器和按内容访问的存储器
   5. 按寻址方式可分为随机存储器、顺序存储器和直接存储器

2. 相联存储器

   ​	相联存储器是一种按内容访问的存储器。其工作原理就是把数据或数据的某一部分作为关键字，按顺序写入信息，读出时并行地将改关键字与存储器中的每一单元进行比较，找出存储器中所有与关键字相同的数据字，特别适合与信息的检索和更新。

3. Cache（高速缓存）

   ​	Cache 用来存放当前最活跃的程序和数据，其特点是：<font color="red">位于 CPU 与主存之间</font>；容量一般在几千字节到几兆字节之间；速度一般比主存快5~10倍；有快速半导体存储器构成；其内容是主存局部域的副本；对程序员来说是透明的。

   1. Cache 中的地址映像方法

      1. 直接映像

         直接映像是指主存的块与 Cache 块的对应关系是固定的，因此，只要主存地址中的主存区号与 Cache 中记录的主存区号相同，则表明访问 Cache 命中。一旦命中，有主存地址中的区内块号立即可得到要访问的 Cache 存储器中的块，而块内地址就是主存地址中给出的地位地址。

         优点：地址变换很简单 

         缺点：灵活性差

      2. 全相联映像

         全相联映像允许主存的任一块可以调入 Cache 存储器的任何一个块的空间中

         在地址变换时，利用主存地址高位表示的主存块号与 Cache 中相联存储器所有单元中记录的主存块号进行比较，若相同即为命中。这时相联存储器单元的编号就对应要访问 Cache 的块号，从而在相应的 Cache 块中更具块内地址访问到相应的存储单元。

         优点：主存的块调入 Cache 的位置不受限制，十分灵活

         缺点：无法从主存块号中直接获取 Cache 的块号，变换比较复杂，速度比较慢

      3. 组相联映像

         这种方法是前两种的折中方法。组相联映像就是规定组采用直接映像方式而块采用全相联映像方式。

         通过直接映像方式来决定组号，在一组内再用全相联映像的方式来决定 Cache 中的块号。有主存地址高位决定的主存区号与 Cache 中区号比较可决定是否命中。主存后面的地址即为组号。

   2. 替换算法

      ​	替换算法的目标就是使 Cacha 获得尽可能高的命中率。

      1. 随机替换算法。用随机数发生器产生一个要替换的块号，将该块替换出去
      2. 先进先出算法。将最先进入 Cacha 的消息块替换出去
      3. 近期最少使用算法。将近期最少使用的 Cacha 中的信息快替换出去
      4. 优先替换算法。必须先执行一次程序，统计 Cacha 的替换情况。有了这样的先验信息，在第二次执行该程序时便可以使用最有效的方式来替换。

   3. Cacha 的性能分析

      Cacha 的性能是计算机体统性能的重要方面。命中率是 Cacha 的一个重要指标，但不是最主要的指标。Cacha 设计的目标是在成本允许的条件下达到较高的命中率，使存储系统具有最端的平均访问时间。设![img](https://latex.codecogs.com/gif.latex?H_c)为 Cacha 的命中率，![img](https://latex.codecogs.com/gif.latex?t_c)为 Cacha 的存取时间，![img](https://latex.codecogs.com/gif.latex?t_m)为主存的访问时间，则 Cacha 存储器的等效加权平均访问时间![img](https://latex.codecogs.com/gif.latex?t_a)为：

   $$
   t_a=H_ct_c+(1-H_c)t_m=t_c+(1-H_c)(t_m-t_c)
   $$
   ​	 这里假设 Cacha 访问和主存访问是同时启动的，其中，![img](https://latex.codecogs.com/gif.latex?t_c)为 Cacha 命中时的访问时间，![img](https://latex.codecogs.com/gif.latex?%28t_m-t_c%29)为失效访问时间。如果在 Cacha 不命中时才启动主存，则
   $$
   t_a=t_c+(1-H_c)t_m
   $$
   ​	在指令流水线中，Cacha 访问作为流水线中的一个操作阶段，Cacha 失效将影响指令的流水。因此，降低 Cacha 的失效率是提高 Cacha 性能的一项重要措施。党 Cacha 容量比较小时，容量因素在 Cacha 失效中占有比较大的比例。降低 Cacha 失效率的方法主要有选择恰当的块容量、提高 Cacha 的容量和提高 Cacha 的相联度等。

   4. 多级 Cacha

   ​	在多级 Cacha 的计算机中，Cacha 分为一级（L1 Cacha）、二级（L2 Cacha）、三级（L3 Cacha）等，CPU 访存时首先查找 L1 Cacha，如果不命中，则访问 L2 Cacha，指导所有级别的 Cacha 都不命中，才访问主存。


