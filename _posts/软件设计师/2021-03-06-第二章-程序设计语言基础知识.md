---

categories: 软件设计师
layout:     post
title:      "第二章 程序设计语言基础知识"
date:       2021-03-06 20:34:55
author:     "Balbo"
header-img: "img/post-bg-2019.jpg"
catalog: true
tags:
    - 软件设计师

---

# 2.2 语言处理程序基础

## 2.2.2 编译程序基本原理

1. 文法和语言的形式描述

   1. 字母表、字符串、字符串集合及运算

      + 字母表 $\sum$ 和字符：字母表时字符的非空有穷集合，字符是字母表 $\sum$ 中的元素。例如 $\sum=\lbrace a,b\rbrace$，a 或 b 是字符。
      + 字符串：$\sum$ 中的字符组成的有穷序列。例如 $a、ab、aaa$ 都是 $\sum$ 上的字符串。
      + 字符串的长度：指字符串中的字符个数。如$\mid aba\mid=3$。
      + 空串 $\varepsilon$：由零个字符组成的序列。如$\mid\varepsilon\mid=0$。
      + 连接：字符串 S 和 T 的连接是指将串 T 接续在串 S 之后，表示为 $S·T$，连接符号“·”可省略。显然，对于字母表 $\sum$ 上的任意字符串 S，$S·\varepsilon=\varepsilon·S=S$。
      + $\sum^\ast$：指包括空串 $\varepsilon$ 在内的 $\sum$ 上的所有字符串的集合。例如，设 $\sum=\lbrace a,b \rbrace$，$\sum^\ast=\lbrace \varepsilon,a,b,aa,bb,ab,ba,aaa,\cdots\rbrace$。
      + 字符串的方幂：把字符 $\alpha$ 自身连接 n 次得到的串，称为字符串 $\alpha$ 的 n 次方幂，记为 $\alpha^n$。$ \alpha^0=\varepsilon,\alpha^n=\alpha\alpha^{n-1}=\alpha^{n-1}\alpha$(n>0)。
      + 字符串集合的运算：设A、B代表字母表 $\sum$ 上的两个字符串集合。
        + 或（合并）：$A\bigcup B=\lbrace\alpha\mid\alpha\in A或\alpha\in B\rbrace$。
        + 积（连接）：$AB=\lbrace\alpha\beta\mid\alpha\in A且\beta\in B\rbrace$。
        + 幂：$A^n=A*A^{n-1}=A^{n-1}*A(n>0)$，并规定$A^0=\lbrace\varepsilon\rbrace$。
        + 正则闭包+：$A^+=A^1\bigcup A^2\bigcup A^3\bigcup \cdots\bigcup A^n\bigcup \cdots$。
        + 闭包$^\ast$： $A^\ast=A^0∨A^+$。显然，$\sum^\ast=\sum^0∨\sum^1∨\sum^2∨\cdots∨\sum^n∨\cdots$。

   2. 文法和语言的形式描述

      1. 文法的定义

           描述语言语法结构的规则称为文法。文法 G 是一个四元组，可表示为 $G=(V_N,V_T,P,S)$,其中 $V_T$ 是一个非空有限集，其每个元素称为一个终结符；$V_N$ 是一个非空有限集，其每个元素称为非终结符。$V_N\bigcap V_T=\phi$，即 $V_N$ 和 $V_T$不含公共元素。令$V=V_N\bigcup V_T$，称 V 为文法 G 的词汇表，V 中的符号称为文法符号，包括终结符和非终结符。P 是产生式的有限集合，每个产生式是形如 $\alpha\to\beta$ 的规则，其中，$\alpha$ 称为产生式的左部，$\alpha\in V^+$ 且 $\alpha$ 中至少含有一个非终结符；$\beta$ 称为产生式的右部，且$\beta\in V^\ast$。若干个产生式$\alpha\to\beta_1,\alpha\to\beta_2,\cdots,\alpha\to\beta_n$ 的左部相同时，可简写为 $\alpha\to\beta_1\mid\beta_2\mid\cdots\mid\beta_n$，称$\beta_i(1\leq i\leq n)$ 为 $\alpha$ 的一个候选式。$S\in V_N$，称为开始符号，它至少要在一条产生式中作为左部出现。

      2. 文法的分类

           文法分成 4 中类型，即 0 型、1 型、2 型和 3 型。

           若文法 $G=(V_N,V_T,P,S)$ 的每个产生式 $\alpha\to\beta$，均有 $\alpha\in(V_N\bigcup V_T)^+$，$\alpha$ 至少含有一个非终结符，且 $\beta\in(V_N\bigcup V_T)^\ast$，则称 G 为 0 型文法。对 0 型文法的每条产生式分别施加以下限制，则可得以下文法：

         + 1 型文法：G 的任何产生式 $\alpha\to\beta$（ $S\to\varepsilon$ 除外）均满足 $\mid\alpha\mid\leq\mid\beta\mid$（$\mid x\mid$表示 x 中文法符号的个数）
         + 2 型文法：G 的任何产生式 $A\to\beta$，其中$A\in V_N$，$\beta\in(V_N\bigcup V_T)^\ast$。
         + 3 型文法：G 的任何产生式 $A\to a$ 或 $A\to aB$（或者$A\to Bb$），其中 $A，B\in V_N,a\in V_T$。

      3. 句子和语言

           设有文法 $G=(V_N,V_T,P,S)$

           + 推导与直接推导：

               推导就是从文法的开始符号 S 出发，反复使用产生式，将产生式左部的非终结符替换为右部的文法符号序列，知道产生一个终结符的序列时为止。若有产生式 $\alpha\to\beta\in P$，$\gamma$，$\delta\in V^\ast$，则 $\gamma\alpha\delta\implies \gamma\beta\delta$ 称为文法 G 中的一个直接推导，并称 $\gamma\alpha\delta$ 可直接推导出 $\gamma\beta\delta$。显然，对于 P 中的每一个产生式 $\alpha\to\beta$ 都有 $\alpha\implies \beta$。若在文法中存在一个直接推导序列，即 $\alpha_0\implies\alpha_1\implies\alpha_2\implies\cdots\implies\alpha_n(n>0)$，则称 $\alpha_0$ 可推导出 $\alpha_n$，$\alpha_n$ 是 $\alpha_0$ 的一个推导，并记为 $\alpha_0\implies^+_G\alpha_n$。用记号  $\alpha_0\implies^\ast_G\alpha_n$ 表示 $\alpha_0\implies\alpha_n$ 或者 $\alpha_0\implies^+_G\alpha_n$。

           + 直接归约与归约：

               若文法 G 中有一个直接推导 $\alpha\implies \beta$，则称 $\beta$ 可直接归约成 $\alpha$，或 $\alpha$ 是 $\beta$ 的一个直接归约。若文法 G 中有一个推导 $\gamma\implies^\ast_G\delta$，则称 $\delta$ 可归约成 $\gamma$，或 $\gamma$ 是 $\delta$ 的一个归约。

           + 句型和句子：

               若文法 G 的开始符号为 S，那么，从开始符号 S 能推导出的符号串称为文法的一个句型，即 $\alpha$ 是文法 G 的一个句型，当且仅当存在推导 $S\implies^\ast_G\alpha,\alpha\in V^\ast$。若 X 是文法 G 的一个句型，且 $X\in V_T^\ast$，则称 X 是文法 G的一个句子，即仅含终结符的句型是一个句子。

           + 语言：

               从文法 G 的开始符号出发，能推导出的句子的全体称为文法 G 产生的语言，记为L(G)。

      4. 文法的等价

        若文法 $G_1$ 与文法 $G_2$ 产生的语言相同，即 $L(G_1)=L(G_2)$，则称这两个文法是等价的。

2. 词法分析

   语言中具有独立含义的最小语法单位是符号，如标识符、无符号常数与界限符等。词法分析的任务是把构成源程序的字符串转换成凡此符号序列。

   1. 正规表达式和正规集

      对于字母表 $\sum$，其上的正规式机器表示的正规集可以递归定义如下。

      1. $\varepsilon$ 是一个正规式，它表示集合 $L(\varepsilon)=\lbrace\varepsilon\rbrace$。

      2. 若 a 是 $\sum$ 上的字符，则 a 是一个正规式，它所表示的正规集为 $\lbrace a\rbrace$。

      3. 若正规式 r 和 s 分别表示正规集 L(r) 和 L(s)，则：

         1. $r\mid s$ 是正规式，表示集合 $L(r)∨L(s)$。
         2. $r·s$ 是正规式，表示集合 $L(r)L(s)$。
         3. $r^\ast$ 是正规式，表示集合 $(L(r))^\ast$。
         4. $(r)$ 是正规式，表示集合 $L(r)$。

         仅通过有限次地使用上述 3 个步骤定义的表达式才是 $\sum$ 上的正规式，其中，运算符“ \| ”、“ · ” 和 “ \* ”分别称为”或“、”连接”和“闭包”。在正规式的书写中，连接运算符“ · ”可以省略。运算符的优先级从高到低顺序排列为“ \* ”、“ · ”、“ \| ”。

         | 正规式                                    | 正规集                                                       |
         | ----------------------------------------- | ------------------------------------------------------------ |
         | $a$                                       | $\lbrace a\rbrace$                                           |
         | $a\mid b$​                                 | $\lbrace a,b\rbrace$                                         |
         | $ab$                                      | $\lbrace ab\rbrace$                                          |
         | $(a\mid b)(a\mid b)$                      | $\lbrace aa,ab,ba,bb\rbrace$                                 |
         | $a^\ast$                                  | $\lbrace ε,a,a, ……任意个a的串\rbrace$                        |
         | $(a\mid b)^\ast$                          | $\lbrace ε,a,b,aa,ab ……所有由a和b组成的串\rbrace$            |
         | $(a\mid b)^\ast(aa\mid bb)(a\mid b)^\ast$ | $\lbrace∑^\ast上所有含有两个相继的a或两个相继的b组成的串\rbrace$ |

   2. 有限自动机

        有限自动机是一种识别装置的抽象概念，它能准确地识别正规集。有限自动化分为两类：确定的有限自动机和不确定的有限自动机。

      1. 确定的有限自动机(Deterministic Finite Automata, DFA)。一个确定的有限自动机是一个五元组（$S,\sum,f,s_0,Z$），其中：

         + S 是一个有限集，其每个元素称为一个状态
         + $\sum$ 是一个有穷字母表，其每个元素称为一个输入字符
         + f 是 $S×\sum\to S$ 上的单值部分映像。$f(A,a)=Q$ 表示当前状态为A、输入为 a 时，将转换到下一状态 Q，称 Q 为 A 的一个后继状态
         + $s_0\in S$，时唯一的一个开始状态
         + Z 时非空的终止状态集合，$Z⊆S$

           一个 DFA 可以用两种直观的方式表示：状态转换图和状态转换矩阵。状态转换图简称为转换图，时一个有向图。DFA 中的每个状态对应转换图中的一个结点，DFA 中的每个转换函数对应图中的一条有向弧，若转换函数为 $f(A,a)=Q$，则该有向弧从结点 A 出发，进入结点 Q，字符 a 是弧上的标记。

      【例 2.1】已知有 $DFA M1=(\lbrace s_0,s_1,s_2,s_3\rbrace,\lbrace a,b\rbrace,f,s_0,\lbrace s_3\rbrace)$，其中 f 为：

      $f(s_0,a)=s_1,f(s_0,b)=s_2,f(s_1,b)=s_3,f(s_1,b)=s_2,f(s_2,a)=s_1,f(s_2,b)=s_3,f(s_3,a)=s_3$

      与 $DFAM1$ 对应的状态图如图 2-7(a) 所示，其中，双圈表示的结点时终态结点。状态转换矩阵可以用一个二维数组 M 表示，矩阵元素 M[A，a] 的行下标表示状态，列下标表示输入字符，M[A,a] 的值是当前状态为 A，输入为 a 时应转换到的下一状态。与 $DFAM1$ 对应的状态转换矩阵如图 2-7(b) 所示。在转换矩阵中，一般以第一行的行下标所对应的状态作为初态，而终态则需要特别指明。
      
      ![（a）状态转换图](img/software/state_transition_1.png)
      
      |       |   a   |   b   |
      | :---: | :---: | :---: |
      | $s_0$ | $s_1$ | $s_2$ |
      | $s_1$ | $s_3$ | $s_2$ |
      | $s_2$ | $s_1$ | $s_3$ |
      | $s_3$ | $s_1$ |   _   |
      
       <center>（b）状态转换矩阵</center>
      
      2. 不确定的有限自动机(Nondeterministic Finite Automata, NFA)。一个不确定的有限自动机是一个五元组，它与确定的有限自动机的区别如下。
      
         1. f 是 $S×\sum\to 2^S$ 上的映像。对于 S 中的一个给定状态及输入符号，返回一个状态的集合。即当前状态的后继状态不一定是唯一的。
         2. 有向弧上的标记可以是 $\varepsilon$。
      
         【例 2.2】已知有 $DFAM2=(\lbrace s_0,s_1,s_2,s_3\rbrace,\lbrace a,b\rbrace,f,s_0,\lbrace s_3\rbrace)$，其中 f 为：
      
         $f(s_0,a)=s_0,f(s_0,a)=s_1,f(s_0,b)=s_0,f(s_1,b)=s_2,f(s_2,b)=s_3$
      
         与 $DFAM2$ 对应的状态图如图 2-8 所示
      
         ![（a）状态转换图](img/software/state_transition_2.png)
      
         |       |            a             |          b           |
         | :---: | :----------------------: | :------------------: |
         | $s_0$ | $\lbrace s_0,s_1\rbrace$ | $\lbrace s_0\rbrace$ |
         | $s_1$ |            _             | $\lbrace s_2\rbrace$ |
         | $s_2$ |            _             | $\lbrace s_3\rbrace$ |
         | $s_3$ |            _             |          _           |
      
          <center>（b）状态转换矩阵</center>
      
         显然，$DFA$ 是 $NFA$ 的特例。实际上，对于每个 $NFAM$，都存在一个 $DFAN$，且 $L(M)=L(N)$。对于任何两个有限自动机 $M1$ 和 $M2$，如果 $L(M1)=L(M2)$，则称 $M1$ 和 $M2$ 是等价的。

3. 正归式与有限自动机之间的转换

     1. 有限自动机转换为正规式

        对于 $\sum$ 上的 $NFAM$，可以构造一个 $\sum$ 上的正规式 R，使得 $L(R)=L(M)$。

          1. 在 M 的状态转换图中加两个结点，一个 x 结点，一个 y 结点。从 x 结点到 $NFA M$ 的初始状态结点引一条弧并用 $\varepsilon$ 标记，从 $NFA M$ 的所有终态结点到 y 结点引一条弧并用 $\varepsilon$ 标记。形成一个与 M 等价的 $M^‘$，$M^‘$ 只有一个初态 x 和一个终台 y。

          2. 按下面的方法逐步消去 $M^‘$ 中除 x 和 y 的所有结点。在消除结点的过程中，用正规式来标记弧，最后结点 x 和 y 之间弧上的标记就是所求的正规式。消除结点的规则如图所示。

             ![（a）状态转换图](img/software/state_transition_3.png)

     2. 正规式转换为有限自动机

         对于 $\sum$ 上的每个正规式 $R$，可以构造一个 $\sum$ 上的 $NFAM$，使得 $L(M)=L(R)$。

          1. 对于正规式 R，可用拓广图表示。

             ![（a）状态转换图](img/software/outreach.png)

          2. 按下面的方法逐步消去 $M^‘$ 中除 x 和 y 的所有结点。在消除结点的过程中，用正规式来标记弧，最后结点 x 和 y 之间弧上的标记就是所求的正规式。消除结点的规则如图所示。

             ![（a）状态转换图](img/software/state_transition_4.png)

         最后所得的图即为一个 NFAM，x 为初态结点，y 为终态结点。显然，$L(M)=L(R)$。

4. 词法分析器的构造

     1. 用正规式描述语言中的单词构成规则
     2. 为每个正规式构造一个 NFA，它识别正规式所表示的正规集
     3. 将构造出的 NFA 转换成等价的 DFA
     4. 对 DFA 惊醒最小化处理，使其最简
     5. 从 DFA 构造词法分析器

5. 语法分析

     语法分析的任务是根据语言的语法规则分析单词串是否构成短语和句子，即表达式、语句和程序等基本语言结构，同时检查和处理程序中的语法错误。根据产生语法树的方向，可分为自底向上和自顶向下两类。

6. 语法制导翻译和中间代码生成

     程序设计语言的语义分为静态语义和动态语义。描述程序语义的形式化方法主要有属性文法、公理语义、操作语义和指称语义等，其中，属性文法是对上下文无关文法的补充。目前应用最广的静态语义分析方法是语法制导翻译，其基本思想是将语言结构的语义以属性的形式赋予代表此结构的文法符号，而属性的计算以语义规则的形式赋予文法的产生式。在语法分析的推导或归约的步骤中，通过执行语义规则实现对属性的计算，以达到对语义的处理。

     1. 中间代码
        1. 后缀式（逆波兰式）。例：x:=(a+b)\*(c+d)，表示为：xab+cd+\*:=

        2. 树形表示。例：x:=(a+b)\*(c+d)，表示为：

           ![（a）状态转换图](img/software/tree.png)

        3. 三元式表示。例：x:=(a+b)\*(c+d)，表示为：
        
           1. (+,a,b,t1)
           2. (+,c,d,t2)
           3. (*,t1,t2,t3)
           4. (:=,t3,_,x)

7. 中间代码优化和目标代码生成

     优化就是对程序进行等价交换，使得从变换后的程序能生成更有效的目标代码。所谓等价，是指不改变程序的运行结果；所谓有效，是指目标代码的运行时间较短，占用的存储空间较少。优化可在编译的各个阶段进行。最主要的优化是在目标代码生成以前对中间代码进行的，这类优化不依赖于具体的计算机。

     代码生成所需考虑的主要问题如下：

     1. 中间代码形式。中间代码有多种形式，其中树与后缀表示形式适用于解释器，而编译器多采用与机器指令格式较接近的四元式形式。
     2. 目标代码形式。目标代码可以分为两大类：汇编语言形式和机器指令形式。机器指令形式的目标代码又可以根据需求的不同分为绝对机器指令代码和可再定位机器代码。绝对机器代码的优点是可以立即执行，一般应用于一类称为 load-and-go 形式的编译模式，即编译后立即执行，不形成保存在外存上的目标代码文件。可再定位机器代码的优点是目标代码可以被任意链接并装入内存的任意位置，它是编译器采用较多的代码形式。汇编语言作为一种中间输出形式，便于进行分析和测试。
     3. 寄存器的分配。由于访问寄存器的速度远远快于方位单元的速度，所以人们总是希望尽可能多地使用寄存器存储数据，而寄存器的个数是有限的，因此，如何分配及使用寄存器是目标代码生成时需要着重考虑的。
     4. 计算次序的选择。代码执行的效率会随计算次序的不同有较大的差别。在生成正确目标代码的前提下适当地安排计算次序并优化代码序列，也是生成目标代码时要考虑的重要因素之一。

## 2.2.3 解释程序基本原理

1. 解释程序的基本结构

   解释程序通常可以分成两部分：第一部分是分析部分，包括通常的词法分析、语法分析和语义分析程序，经语义分析后把源程序翻译成中间代码，中间代码常采用逆波兰表示形式。第二部分是解释部分，用来对第一部分产生的中间代码进行解释执行。下面简要介绍第二部分的工作原理。

   设用数组 MEM 模拟计算机的内存，源程序的中间代码和解释部分的各个子程序都存放在数组 MEM 中。全局变量 PC 是一个程序计数器，它记录了当前正在执行的中间代码的位置。这种解释部分的常见结构可以由下面两部分组成。

   1. PC:=PC+1
   2. 执行位于 opcode-table[MEM[PC]] 的子程序（解释子程序执行后返回到前面）

   下面用一个简单的例子来说明其工作原理。设两个实型变量 A 和 B 进行相加的中间代码：

   ```c
   start:	Ipush
   			A
   		Ipush
   			B
   		Iaddreal
   ```

   其中，中间代码 Ipush 和 Iaddreal 实际上都是 opcode-table 表的索引值（即位移），而该表的单元中存放的值就是对应的解释子程序的起始地址，A 和 B 都是 MEM 中的索引值。解释部分开始执行时，PC 的值为 start-1。

   ```c
   opcode-table[Ipush]=push
   opcode-table[Iaddreal]=addreal
   ```

   解释部分可表示如下：

   ```c
   interpreter-loop:	PC:=PC+1;
   				   goto opcode-table[MEM[PC]];
   		    push:   PC:=PC+1;
   				   stackreal(MEM[MEM[PC]]);
   				   goto interpreter-loop;
   		 addreal:   stackreal(popreal()+popreal());
   		 		   goto interpreter-loop; 
   ...
   ```

   其中，stackreal() 表示把相应值压入栈中，而 popreal() 表示取得栈顶元素值并弹出栈顶元素。上面代码基于栈实现了将两个数值相加并将结果存入栈中的处理。

2. 高级语言翻译与解释方式的比较

   1. 效率。编译比解释方式可能取得更高的效率。
   
   2. 灵活性。由于解释程序需要反复检查源程序，这也使得解释方式能够比编译方式更灵活。
   
   3. 可移植性。解释器一般也是用某种程序设计语言编写的，因此只要对解释器进行重新编译，即可以使解释器运行在不同的环境中。
   
      $$
      \begin{aligned}
      a=&\left(1+2+3+  \cdots \right. \\
      & \cdots+ \left. \infty-2+\infty-1+\infty\right)
      \end{aligned}
      $$

